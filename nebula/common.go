// Code generated by Thrift Compiler (0.19.0). DO NOT EDIT.

package nebula

import (
	"bytes"
	"context"
	"database/sql/driver"
	"errors"
	"fmt"
	"time"
	thrift "github.com/apache/thrift/lib/go/thrift"
	"strings"
	"regexp"
)

// (needed to ensure safety because of naive import list construction.)
var _ = thrift.ZERO
var _ = fmt.Printf
var _ = errors.New
var _ = context.Background
var _ = time.Now
var _ = bytes.Equal
// (needed by validator.)
var _ = strings.Contains
var _ = regexp.MatchString

type NullType int64
const (
  NullType___NULL__ NullType = 0
  NullType_NaN NullType = 1
  NullType_BAD_DATA NullType = 2
  NullType_BAD_TYPE NullType = 3
  NullType_ERR_OVERFLOW NullType = 4
  NullType_UNKNOWN_PROP NullType = 5
  NullType_DIV_BY_ZERO NullType = 6
  NullType_OUT_OF_RANGE NullType = 7
)

func (p NullType) String() string {
  switch p {
  case NullType___NULL__: return "__NULL__"
  case NullType_NaN: return "NaN"
  case NullType_BAD_DATA: return "BAD_DATA"
  case NullType_BAD_TYPE: return "BAD_TYPE"
  case NullType_ERR_OVERFLOW: return "ERR_OVERFLOW"
  case NullType_UNKNOWN_PROP: return "UNKNOWN_PROP"
  case NullType_DIV_BY_ZERO: return "DIV_BY_ZERO"
  case NullType_OUT_OF_RANGE: return "OUT_OF_RANGE"
  }
  return "<UNSET>"
}

func NullTypeFromString(s string) (NullType, error) {
  switch s {
  case "__NULL__": return NullType___NULL__, nil 
  case "NaN": return NullType_NaN, nil 
  case "BAD_DATA": return NullType_BAD_DATA, nil 
  case "BAD_TYPE": return NullType_BAD_TYPE, nil 
  case "ERR_OVERFLOW": return NullType_ERR_OVERFLOW, nil 
  case "UNKNOWN_PROP": return NullType_UNKNOWN_PROP, nil 
  case "DIV_BY_ZERO": return NullType_DIV_BY_ZERO, nil 
  case "OUT_OF_RANGE": return NullType_OUT_OF_RANGE, nil 
  }
  return NullType(0), fmt.Errorf("not a valid NullType string")
}


func NullTypePtr(v NullType) *NullType { return &v }

func (p NullType) MarshalText() ([]byte, error) {
return []byte(p.String()), nil
}

func (p *NullType) UnmarshalText(text []byte) error {
q, err := NullTypeFromString(string(text))
if (err != nil) {
return err
}
*p = q
return nil
}

func (p *NullType) Scan(value interface{}) error {
v, ok := value.(int64)
if !ok {
return errors.New("Scan value is not int64")
}
*p = NullType(v)
return nil
}

func (p * NullType) Value() (driver.Value, error) {
  if p == nil {
    return nil, nil
  }
return int64(*p), nil
}
type PropertyType int64
const (
  PropertyType_UNKNOWN PropertyType = 0
  PropertyType_BOOL PropertyType = 1
  PropertyType_INT64 PropertyType = 2
  PropertyType_VID PropertyType = 3
  PropertyType_FLOAT PropertyType = 4
  PropertyType_DOUBLE PropertyType = 5
  PropertyType_STRING PropertyType = 6
  PropertyType_FIXED_STRING PropertyType = 7
  PropertyType_INT8 PropertyType = 8
  PropertyType_INT16 PropertyType = 9
  PropertyType_INT32 PropertyType = 10
  PropertyType_TIMESTAMP PropertyType = 21
  PropertyType_DURATION PropertyType = 23
  PropertyType_DATE PropertyType = 24
  PropertyType_DATETIME PropertyType = 25
  PropertyType_TIME PropertyType = 26
  PropertyType_GEOGRAPHY PropertyType = 31
  PropertyType_LIST_STRING PropertyType = 32
  PropertyType_LIST_INT PropertyType = 33
  PropertyType_LIST_FLOAT PropertyType = 34
  PropertyType_SET_STRING PropertyType = 35
  PropertyType_SET_INT PropertyType = 36
  PropertyType_SET_FLOAT PropertyType = 37
)

func (p PropertyType) String() string {
  switch p {
  case PropertyType_UNKNOWN: return "UNKNOWN"
  case PropertyType_BOOL: return "BOOL"
  case PropertyType_INT64: return "INT64"
  case PropertyType_VID: return "VID"
  case PropertyType_FLOAT: return "FLOAT"
  case PropertyType_DOUBLE: return "DOUBLE"
  case PropertyType_STRING: return "STRING"
  case PropertyType_FIXED_STRING: return "FIXED_STRING"
  case PropertyType_INT8: return "INT8"
  case PropertyType_INT16: return "INT16"
  case PropertyType_INT32: return "INT32"
  case PropertyType_TIMESTAMP: return "TIMESTAMP"
  case PropertyType_DURATION: return "DURATION"
  case PropertyType_DATE: return "DATE"
  case PropertyType_DATETIME: return "DATETIME"
  case PropertyType_TIME: return "TIME"
  case PropertyType_GEOGRAPHY: return "GEOGRAPHY"
  case PropertyType_LIST_STRING: return "LIST_STRING"
  case PropertyType_LIST_INT: return "LIST_INT"
  case PropertyType_LIST_FLOAT: return "LIST_FLOAT"
  case PropertyType_SET_STRING: return "SET_STRING"
  case PropertyType_SET_INT: return "SET_INT"
  case PropertyType_SET_FLOAT: return "SET_FLOAT"
  }
  return "<UNSET>"
}

func PropertyTypeFromString(s string) (PropertyType, error) {
  switch s {
  case "UNKNOWN": return PropertyType_UNKNOWN, nil 
  case "BOOL": return PropertyType_BOOL, nil 
  case "INT64": return PropertyType_INT64, nil 
  case "VID": return PropertyType_VID, nil 
  case "FLOAT": return PropertyType_FLOAT, nil 
  case "DOUBLE": return PropertyType_DOUBLE, nil 
  case "STRING": return PropertyType_STRING, nil 
  case "FIXED_STRING": return PropertyType_FIXED_STRING, nil 
  case "INT8": return PropertyType_INT8, nil 
  case "INT16": return PropertyType_INT16, nil 
  case "INT32": return PropertyType_INT32, nil 
  case "TIMESTAMP": return PropertyType_TIMESTAMP, nil 
  case "DURATION": return PropertyType_DURATION, nil 
  case "DATE": return PropertyType_DATE, nil 
  case "DATETIME": return PropertyType_DATETIME, nil 
  case "TIME": return PropertyType_TIME, nil 
  case "GEOGRAPHY": return PropertyType_GEOGRAPHY, nil 
  case "LIST_STRING": return PropertyType_LIST_STRING, nil 
  case "LIST_INT": return PropertyType_LIST_INT, nil 
  case "LIST_FLOAT": return PropertyType_LIST_FLOAT, nil 
  case "SET_STRING": return PropertyType_SET_STRING, nil 
  case "SET_INT": return PropertyType_SET_INT, nil 
  case "SET_FLOAT": return PropertyType_SET_FLOAT, nil 
  }
  return PropertyType(0), fmt.Errorf("not a valid PropertyType string")
}


func PropertyTypePtr(v PropertyType) *PropertyType { return &v }

func (p PropertyType) MarshalText() ([]byte, error) {
return []byte(p.String()), nil
}

func (p *PropertyType) UnmarshalText(text []byte) error {
q, err := PropertyTypeFromString(string(text))
if (err != nil) {
return err
}
*p = q
return nil
}

func (p *PropertyType) Scan(value interface{}) error {
v, ok := value.(int64)
if !ok {
return errors.New("Scan value is not int64")
}
*p = PropertyType(v)
return nil
}

func (p * PropertyType) Value() (driver.Value, error) {
  if p == nil {
    return nil, nil
  }
return int64(*p), nil
}
type ErrorCode int64
const (
  ErrorCode_SUCCEEDED ErrorCode = 0
  ErrorCode_E_DISCONNECTED ErrorCode = -1
  ErrorCode_E_FAIL_TO_CONNECT ErrorCode = -2
  ErrorCode_E_RPC_FAILURE ErrorCode = -3
  ErrorCode_E_LEADER_CHANGED ErrorCode = -4
  ErrorCode_E_SPACE_NOT_FOUND ErrorCode = -5
  ErrorCode_E_TAG_NOT_FOUND ErrorCode = -6
  ErrorCode_E_EDGE_NOT_FOUND ErrorCode = -7
  ErrorCode_E_INDEX_NOT_FOUND ErrorCode = -8
  ErrorCode_E_EDGE_PROP_NOT_FOUND ErrorCode = -9
  ErrorCode_E_TAG_PROP_NOT_FOUND ErrorCode = -10
  ErrorCode_E_ROLE_NOT_FOUND ErrorCode = -11
  ErrorCode_E_CONFIG_NOT_FOUND ErrorCode = -12
  ErrorCode_E_MACHINE_NOT_FOUND ErrorCode = -13
  ErrorCode_E_ZONE_NOT_FOUND ErrorCode = -14
  ErrorCode_E_LISTENER_NOT_FOUND ErrorCode = -15
  ErrorCode_E_PART_NOT_FOUND ErrorCode = -16
  ErrorCode_E_KEY_NOT_FOUND ErrorCode = -17
  ErrorCode_E_USER_NOT_FOUND ErrorCode = -18
  ErrorCode_E_STATS_NOT_FOUND ErrorCode = -19
  ErrorCode_E_SERVICE_NOT_FOUND ErrorCode = -20
  ErrorCode_E_DRAINER_NOT_FOUND ErrorCode = -21
  ErrorCode_E_DRAINER_CLIENT_NOT_FOUND ErrorCode = -22
  ErrorCode_E_PART_STOPPED ErrorCode = -23
  ErrorCode_E_BACKUP_FAILED ErrorCode = -24
  ErrorCode_E_BACKUP_EMPTY_TABLE ErrorCode = -25
  ErrorCode_E_BACKUP_TABLE_FAILED ErrorCode = -26
  ErrorCode_E_PARTIAL_RESULT ErrorCode = -27
  ErrorCode_E_REBUILD_INDEX_FAILED ErrorCode = -28
  ErrorCode_E_INVALID_PASSWORD ErrorCode = -29
  ErrorCode_E_FAILED_GET_ABS_PATH ErrorCode = -30
  ErrorCode_E_LISTENER_PROGRESS_FAILED ErrorCode = -31
  ErrorCode_E_SYNC_LISTENER_NOT_FOUND ErrorCode = -32
  ErrorCode_E_DRAINER_PROGRESS_FAILED ErrorCode = -33
  ErrorCode_E_PART_DISABLED ErrorCode = -34
  ErrorCode_E_PART_ALREADY_STARTED ErrorCode = -35
  ErrorCode_E_PART_ALREADY_STOPPED ErrorCode = -36
  ErrorCode_E_BAD_USERNAME_PASSWORD ErrorCode = -1001
  ErrorCode_E_SESSION_INVALID ErrorCode = -1002
  ErrorCode_E_SESSION_TIMEOUT ErrorCode = -1003
  ErrorCode_E_SYNTAX_ERROR ErrorCode = -1004
  ErrorCode_E_EXECUTION_ERROR ErrorCode = -1005
  ErrorCode_E_STATEMENT_EMPTY ErrorCode = -1006
  ErrorCode_E_BAD_PERMISSION ErrorCode = -1008
  ErrorCode_E_SEMANTIC_ERROR ErrorCode = -1009
  ErrorCode_E_TOO_MANY_CONNECTIONS ErrorCode = -1010
  ErrorCode_E_PARTIAL_SUCCEEDED ErrorCode = -1011
  ErrorCode_E_NO_HOSTS ErrorCode = -2001
  ErrorCode_E_EXISTED ErrorCode = -2002
  ErrorCode_E_INVALID_HOST ErrorCode = -2003
  ErrorCode_E_UNSUPPORTED ErrorCode = -2004
  ErrorCode_E_NOT_DROP ErrorCode = -2005
  ErrorCode_E_BALANCER_RUNNING ErrorCode = -2006
  ErrorCode_E_CONFIG_IMMUTABLE ErrorCode = -2007
  ErrorCode_E_CONFLICT ErrorCode = -2008
  ErrorCode_E_INVALID_PARM ErrorCode = -2009
  ErrorCode_E_WRONGCLUSTER ErrorCode = -2010
  ErrorCode_E_ZONE_NOT_ENOUGH ErrorCode = -2011
  ErrorCode_E_ZONE_IS_EMPTY ErrorCode = -2012
  ErrorCode_E_LISTENER_CONFLICT ErrorCode = -2013
  ErrorCode_E_SCHEMA_NAME_EXISTS ErrorCode = -2014
  ErrorCode_E_RELATED_INDEX_EXISTS ErrorCode = -2015
  ErrorCode_E_RELATED_SPACE_EXISTS ErrorCode = -2016
  ErrorCode_E_RELATED_FULLTEXT_INDEX_EXISTS ErrorCode = -2017
  ErrorCode_E_HISTORY_CONFLICT ErrorCode = -2018
  ErrorCode_E_STORE_FAILURE ErrorCode = -2021
  ErrorCode_E_STORE_SEGMENT_ILLEGAL ErrorCode = -2022
  ErrorCode_E_BAD_BALANCE_PLAN ErrorCode = -2023
  ErrorCode_E_BALANCED ErrorCode = -2024
  ErrorCode_E_NO_RUNNING_BALANCE_PLAN ErrorCode = -2025
  ErrorCode_E_NO_VALID_HOST ErrorCode = -2026
  ErrorCode_E_CORRUPTED_BALANCE_PLAN ErrorCode = -2027
  ErrorCode_E_NO_INVALID_BALANCE_PLAN ErrorCode = -2028
  ErrorCode_E_NO_VALID_DRAINER ErrorCode = -2029
  ErrorCode_E_IMPROPER_ROLE ErrorCode = -2030
  ErrorCode_E_INVALID_PARTITION_NUM ErrorCode = -2031
  ErrorCode_E_INVALID_REPLICA_FACTOR ErrorCode = -2032
  ErrorCode_E_INVALID_CHARSET ErrorCode = -2033
  ErrorCode_E_INVALID_COLLATE ErrorCode = -2034
  ErrorCode_E_CHARSET_COLLATE_NOT_MATCH ErrorCode = -2035
  ErrorCode_E_PRIVILEGE_ALL_TAG_EDGE_SETTLED ErrorCode = -2036
  ErrorCode_E_PRIVILEGE_NOT_EXIST ErrorCode = -2037
  ErrorCode_E_PRIVILEGE_NEED_BASIC_ROLE ErrorCode = -2038
  ErrorCode_E_PRIVILEGE_ACTION_INVALID ErrorCode = -2039
  ErrorCode_E_SNAPSHOT_FAILURE ErrorCode = -2040
  ErrorCode_E_SNAPSHOT_RUNNING_JOBS ErrorCode = -2056
  ErrorCode_E_SNAPSHOT_NOT_FOUND ErrorCode = -2057
  ErrorCode_E_BLOCK_WRITE_FAILURE ErrorCode = -2041
  ErrorCode_E_REBUILD_INDEX_FAILURE ErrorCode = -2042
  ErrorCode_E_INDEX_WITH_TTL ErrorCode = -2043
  ErrorCode_E_ADD_JOB_FAILURE ErrorCode = -2044
  ErrorCode_E_STOP_JOB_FAILURE ErrorCode = -2045
  ErrorCode_E_SAVE_JOB_FAILURE ErrorCode = -2046
  ErrorCode_E_BALANCER_FAILURE ErrorCode = -2047
  ErrorCode_E_JOB_NOT_FINISHED ErrorCode = -2048
  ErrorCode_E_TASK_REPORT_OUT_DATE ErrorCode = -2049
  ErrorCode_E_JOB_NOT_IN_SPACE ErrorCode = -2050
  ErrorCode_E_JOB_NEED_RECOVER ErrorCode = -2051
  ErrorCode_E_JOB_ALREADY_FINISH ErrorCode = -2052
  ErrorCode_E_JOB_SUBMITTED ErrorCode = -2053
  ErrorCode_E_JOB_NOT_STOPPABLE ErrorCode = -2054
  ErrorCode_E_JOB_HAS_NO_TARGET_STORAGE ErrorCode = -2055
  ErrorCode_E_INVALID_JOB ErrorCode = -2065
  ErrorCode_E_BACKUP_RUNNING_JOBS ErrorCode = -2066
  ErrorCode_E_BACKUP_SPACE_NOT_FOUND ErrorCode = -2067
  ErrorCode_E_RESTORE_FAILURE ErrorCode = -2068
  ErrorCode_E_SESSION_NOT_FOUND ErrorCode = -2069
  ErrorCode_E_LIST_CLUSTER_FAILURE ErrorCode = -2070
  ErrorCode_E_LIST_CLUSTER_GET_ABS_PATH_FAILURE ErrorCode = -2071
  ErrorCode_E_LIST_CLUSTER_NO_AGENT_FAILURE ErrorCode = -2072
  ErrorCode_E_QUERY_NOT_FOUND ErrorCode = -2073
  ErrorCode_E_AGENT_HB_FAILUE ErrorCode = -2074
  ErrorCode_E_INVALID_VARIABLE ErrorCode = -2080
  ErrorCode_E_VARIABLE_TYPE_VALUE_MISMATCH ErrorCode = -2081
  ErrorCode_E_HOST_CAN_NOT_BE_ADDED ErrorCode = -2082
  ErrorCode_E_ACCESS_ES_FAILURE ErrorCode = -2090
  ErrorCode_E_GRAPH_MEMORY_EXCEEDED ErrorCode = -2600
  ErrorCode_E_CONSENSUS_ERROR ErrorCode = -3001
  ErrorCode_E_KEY_HAS_EXISTS ErrorCode = -3002
  ErrorCode_E_DATA_TYPE_MISMATCH ErrorCode = -3003
  ErrorCode_E_INVALID_FIELD_VALUE ErrorCode = -3004
  ErrorCode_E_INVALID_OPERATION ErrorCode = -3005
  ErrorCode_E_NOT_NULLABLE ErrorCode = -3006
  ErrorCode_E_FIELD_UNSET ErrorCode = -3007
  ErrorCode_E_OUT_OF_RANGE ErrorCode = -3008
  ErrorCode_E_DATA_CONFLICT_ERROR ErrorCode = -3010
  ErrorCode_E_WRITE_STALLED ErrorCode = -3011
  ErrorCode_E_IMPROPER_DATA_TYPE ErrorCode = -3021
  ErrorCode_E_INVALID_SPACEVIDLEN ErrorCode = -3022
  ErrorCode_E_INVALID_FILTER ErrorCode = -3031
  ErrorCode_E_INVALID_UPDATER ErrorCode = -3032
  ErrorCode_E_INVALID_STORE ErrorCode = -3033
  ErrorCode_E_INVALID_PEER ErrorCode = -3034
  ErrorCode_E_RETRY_EXHAUSTED ErrorCode = -3035
  ErrorCode_E_TRANSFER_LEADER_FAILED ErrorCode = -3036
  ErrorCode_E_INVALID_STAT_TYPE ErrorCode = -3037
  ErrorCode_E_INVALID_VID ErrorCode = -3038
  ErrorCode_E_NO_TRANSFORMED ErrorCode = -3039
  ErrorCode_E_LOAD_META_FAILED ErrorCode = -3040
  ErrorCode_E_FAILED_TO_CHECKPOINT ErrorCode = -3041
  ErrorCode_E_CHECKPOINT_BLOCKED ErrorCode = -3042
  ErrorCode_E_FILTER_OUT ErrorCode = -3043
  ErrorCode_E_INVALID_DATA ErrorCode = -3044
  ErrorCode_E_MUTATE_EDGE_CONFLICT ErrorCode = -3045
  ErrorCode_E_MUTATE_TAG_CONFLICT ErrorCode = -3046
  ErrorCode_E_OUTDATED_LOCK ErrorCode = -3047
  ErrorCode_E_INVALID_TASK_PARA ErrorCode = -3051
  ErrorCode_E_USER_CANCEL ErrorCode = -3052
  ErrorCode_E_TASK_EXECUTION_FAILED ErrorCode = -3053
  ErrorCode_E_PLAN_IS_KILLED ErrorCode = -3060
  ErrorCode_E_NO_TERM ErrorCode = -3070
  ErrorCode_E_OUTDATED_TERM ErrorCode = -3071
  ErrorCode_E_OUTDATED_EDGE ErrorCode = -3072
  ErrorCode_E_WRITE_WRITE_CONFLICT ErrorCode = -3073
  ErrorCode_E_CLIENT_SERVER_INCOMPATIBLE ErrorCode = -3061
  ErrorCode_E_ID_FAILED ErrorCode = -3062
  ErrorCode_E_RAFT_UNKNOWN_PART ErrorCode = -3500
  ErrorCode_E_RAFT_LOG_GAP ErrorCode = -3501
  ErrorCode_E_RAFT_LOG_STALE ErrorCode = -3502
  ErrorCode_E_RAFT_TERM_OUT_OF_DATE ErrorCode = -3503
  ErrorCode_E_RAFT_UNKNOWN_APPEND_LOG ErrorCode = -3504
  ErrorCode_E_RAFT_WAITING_SNAPSHOT ErrorCode = -3511
  ErrorCode_E_RAFT_SENDING_SNAPSHOT ErrorCode = -3512
  ErrorCode_E_RAFT_INVALID_PEER ErrorCode = -3513
  ErrorCode_E_RAFT_NOT_READY ErrorCode = -3514
  ErrorCode_E_RAFT_STOPPED ErrorCode = -3515
  ErrorCode_E_RAFT_BAD_ROLE ErrorCode = -3516
  ErrorCode_E_RAFT_WAL_FAIL ErrorCode = -3521
  ErrorCode_E_RAFT_HOST_STOPPED ErrorCode = -3522
  ErrorCode_E_RAFT_TOO_MANY_REQUESTS ErrorCode = -3523
  ErrorCode_E_RAFT_PERSIST_SNAPSHOT_FAILED ErrorCode = -3524
  ErrorCode_E_RAFT_RPC_EXCEPTION ErrorCode = -3525
  ErrorCode_E_RAFT_NO_WAL_FOUND ErrorCode = -3526
  ErrorCode_E_RAFT_HOST_PAUSED ErrorCode = -3527
  ErrorCode_E_RAFT_WRITE_BLOCKED ErrorCode = -3528
  ErrorCode_E_RAFT_BUFFER_OVERFLOW ErrorCode = -3529
  ErrorCode_E_RAFT_ATOMIC_OP_FAILED ErrorCode = -3530
  ErrorCode_E_LEADER_LEASE_FAILED ErrorCode = -3531
  ErrorCode_E_RAFT_CAUGHT_UP ErrorCode = -3532
  ErrorCode_E_LOG_GAP ErrorCode = -4001
  ErrorCode_E_LOG_STALE ErrorCode = -4002
  ErrorCode_E_INVALID_DRAINER_STORE ErrorCode = -4003
  ErrorCode_E_SPACE_MISMATCH ErrorCode = -4004
  ErrorCode_E_PART_MISMATCH ErrorCode = -4005
  ErrorCode_E_DATA_CONFLICT ErrorCode = -4006
  ErrorCode_E_REQ_CONFLICT ErrorCode = -4007
  ErrorCode_E_DATA_ILLEGAL ErrorCode = -4008
  ErrorCode_E_CACHE_CONFIG_ERROR ErrorCode = -5001
  ErrorCode_E_NOT_ENOUGH_SPACE ErrorCode = -5002
  ErrorCode_E_CACHE_MISS ErrorCode = -5003
  ErrorCode_E_POOL_NOT_FOUND ErrorCode = -5004
  ErrorCode_E_CACHE_WRITE_FAILURE ErrorCode = -5005
  ErrorCode_E_NODE_NUMBER_EXCEED_LIMIT ErrorCode = -7001
  ErrorCode_E_PARSING_LICENSE_FAILURE ErrorCode = -7002
  ErrorCode_E_STORAGE_MEMORY_EXCEEDED ErrorCode = -3600
  ErrorCode_E_UNKNOWN ErrorCode = -8000
)

func (p ErrorCode) String() string {
  switch p {
  case ErrorCode_SUCCEEDED: return "SUCCEEDED"
  case ErrorCode_E_DISCONNECTED: return "E_DISCONNECTED"
  case ErrorCode_E_FAIL_TO_CONNECT: return "E_FAIL_TO_CONNECT"
  case ErrorCode_E_RPC_FAILURE: return "E_RPC_FAILURE"
  case ErrorCode_E_LEADER_CHANGED: return "E_LEADER_CHANGED"
  case ErrorCode_E_SPACE_NOT_FOUND: return "E_SPACE_NOT_FOUND"
  case ErrorCode_E_TAG_NOT_FOUND: return "E_TAG_NOT_FOUND"
  case ErrorCode_E_EDGE_NOT_FOUND: return "E_EDGE_NOT_FOUND"
  case ErrorCode_E_INDEX_NOT_FOUND: return "E_INDEX_NOT_FOUND"
  case ErrorCode_E_EDGE_PROP_NOT_FOUND: return "E_EDGE_PROP_NOT_FOUND"
  case ErrorCode_E_TAG_PROP_NOT_FOUND: return "E_TAG_PROP_NOT_FOUND"
  case ErrorCode_E_ROLE_NOT_FOUND: return "E_ROLE_NOT_FOUND"
  case ErrorCode_E_CONFIG_NOT_FOUND: return "E_CONFIG_NOT_FOUND"
  case ErrorCode_E_MACHINE_NOT_FOUND: return "E_MACHINE_NOT_FOUND"
  case ErrorCode_E_ZONE_NOT_FOUND: return "E_ZONE_NOT_FOUND"
  case ErrorCode_E_LISTENER_NOT_FOUND: return "E_LISTENER_NOT_FOUND"
  case ErrorCode_E_PART_NOT_FOUND: return "E_PART_NOT_FOUND"
  case ErrorCode_E_KEY_NOT_FOUND: return "E_KEY_NOT_FOUND"
  case ErrorCode_E_USER_NOT_FOUND: return "E_USER_NOT_FOUND"
  case ErrorCode_E_STATS_NOT_FOUND: return "E_STATS_NOT_FOUND"
  case ErrorCode_E_SERVICE_NOT_FOUND: return "E_SERVICE_NOT_FOUND"
  case ErrorCode_E_DRAINER_NOT_FOUND: return "E_DRAINER_NOT_FOUND"
  case ErrorCode_E_DRAINER_CLIENT_NOT_FOUND: return "E_DRAINER_CLIENT_NOT_FOUND"
  case ErrorCode_E_PART_STOPPED: return "E_PART_STOPPED"
  case ErrorCode_E_BACKUP_FAILED: return "E_BACKUP_FAILED"
  case ErrorCode_E_BACKUP_EMPTY_TABLE: return "E_BACKUP_EMPTY_TABLE"
  case ErrorCode_E_BACKUP_TABLE_FAILED: return "E_BACKUP_TABLE_FAILED"
  case ErrorCode_E_PARTIAL_RESULT: return "E_PARTIAL_RESULT"
  case ErrorCode_E_REBUILD_INDEX_FAILED: return "E_REBUILD_INDEX_FAILED"
  case ErrorCode_E_INVALID_PASSWORD: return "E_INVALID_PASSWORD"
  case ErrorCode_E_FAILED_GET_ABS_PATH: return "E_FAILED_GET_ABS_PATH"
  case ErrorCode_E_LISTENER_PROGRESS_FAILED: return "E_LISTENER_PROGRESS_FAILED"
  case ErrorCode_E_SYNC_LISTENER_NOT_FOUND: return "E_SYNC_LISTENER_NOT_FOUND"
  case ErrorCode_E_DRAINER_PROGRESS_FAILED: return "E_DRAINER_PROGRESS_FAILED"
  case ErrorCode_E_PART_DISABLED: return "E_PART_DISABLED"
  case ErrorCode_E_PART_ALREADY_STARTED: return "E_PART_ALREADY_STARTED"
  case ErrorCode_E_PART_ALREADY_STOPPED: return "E_PART_ALREADY_STOPPED"
  case ErrorCode_E_BAD_USERNAME_PASSWORD: return "E_BAD_USERNAME_PASSWORD"
  case ErrorCode_E_SESSION_INVALID: return "E_SESSION_INVALID"
  case ErrorCode_E_SESSION_TIMEOUT: return "E_SESSION_TIMEOUT"
  case ErrorCode_E_SYNTAX_ERROR: return "E_SYNTAX_ERROR"
  case ErrorCode_E_EXECUTION_ERROR: return "E_EXECUTION_ERROR"
  case ErrorCode_E_STATEMENT_EMPTY: return "E_STATEMENT_EMPTY"
  case ErrorCode_E_BAD_PERMISSION: return "E_BAD_PERMISSION"
  case ErrorCode_E_SEMANTIC_ERROR: return "E_SEMANTIC_ERROR"
  case ErrorCode_E_TOO_MANY_CONNECTIONS: return "E_TOO_MANY_CONNECTIONS"
  case ErrorCode_E_PARTIAL_SUCCEEDED: return "E_PARTIAL_SUCCEEDED"
  case ErrorCode_E_NO_HOSTS: return "E_NO_HOSTS"
  case ErrorCode_E_EXISTED: return "E_EXISTED"
  case ErrorCode_E_INVALID_HOST: return "E_INVALID_HOST"
  case ErrorCode_E_UNSUPPORTED: return "E_UNSUPPORTED"
  case ErrorCode_E_NOT_DROP: return "E_NOT_DROP"
  case ErrorCode_E_BALANCER_RUNNING: return "E_BALANCER_RUNNING"
  case ErrorCode_E_CONFIG_IMMUTABLE: return "E_CONFIG_IMMUTABLE"
  case ErrorCode_E_CONFLICT: return "E_CONFLICT"
  case ErrorCode_E_INVALID_PARM: return "E_INVALID_PARM"
  case ErrorCode_E_WRONGCLUSTER: return "E_WRONGCLUSTER"
  case ErrorCode_E_ZONE_NOT_ENOUGH: return "E_ZONE_NOT_ENOUGH"
  case ErrorCode_E_ZONE_IS_EMPTY: return "E_ZONE_IS_EMPTY"
  case ErrorCode_E_LISTENER_CONFLICT: return "E_LISTENER_CONFLICT"
  case ErrorCode_E_SCHEMA_NAME_EXISTS: return "E_SCHEMA_NAME_EXISTS"
  case ErrorCode_E_RELATED_INDEX_EXISTS: return "E_RELATED_INDEX_EXISTS"
  case ErrorCode_E_RELATED_SPACE_EXISTS: return "E_RELATED_SPACE_EXISTS"
  case ErrorCode_E_RELATED_FULLTEXT_INDEX_EXISTS: return "E_RELATED_FULLTEXT_INDEX_EXISTS"
  case ErrorCode_E_HISTORY_CONFLICT: return "E_HISTORY_CONFLICT"
  case ErrorCode_E_STORE_FAILURE: return "E_STORE_FAILURE"
  case ErrorCode_E_STORE_SEGMENT_ILLEGAL: return "E_STORE_SEGMENT_ILLEGAL"
  case ErrorCode_E_BAD_BALANCE_PLAN: return "E_BAD_BALANCE_PLAN"
  case ErrorCode_E_BALANCED: return "E_BALANCED"
  case ErrorCode_E_NO_RUNNING_BALANCE_PLAN: return "E_NO_RUNNING_BALANCE_PLAN"
  case ErrorCode_E_NO_VALID_HOST: return "E_NO_VALID_HOST"
  case ErrorCode_E_CORRUPTED_BALANCE_PLAN: return "E_CORRUPTED_BALANCE_PLAN"
  case ErrorCode_E_NO_INVALID_BALANCE_PLAN: return "E_NO_INVALID_BALANCE_PLAN"
  case ErrorCode_E_NO_VALID_DRAINER: return "E_NO_VALID_DRAINER"
  case ErrorCode_E_IMPROPER_ROLE: return "E_IMPROPER_ROLE"
  case ErrorCode_E_INVALID_PARTITION_NUM: return "E_INVALID_PARTITION_NUM"
  case ErrorCode_E_INVALID_REPLICA_FACTOR: return "E_INVALID_REPLICA_FACTOR"
  case ErrorCode_E_INVALID_CHARSET: return "E_INVALID_CHARSET"
  case ErrorCode_E_INVALID_COLLATE: return "E_INVALID_COLLATE"
  case ErrorCode_E_CHARSET_COLLATE_NOT_MATCH: return "E_CHARSET_COLLATE_NOT_MATCH"
  case ErrorCode_E_PRIVILEGE_ALL_TAG_EDGE_SETTLED: return "E_PRIVILEGE_ALL_TAG_EDGE_SETTLED"
  case ErrorCode_E_PRIVILEGE_NOT_EXIST: return "E_PRIVILEGE_NOT_EXIST"
  case ErrorCode_E_PRIVILEGE_NEED_BASIC_ROLE: return "E_PRIVILEGE_NEED_BASIC_ROLE"
  case ErrorCode_E_PRIVILEGE_ACTION_INVALID: return "E_PRIVILEGE_ACTION_INVALID"
  case ErrorCode_E_SNAPSHOT_FAILURE: return "E_SNAPSHOT_FAILURE"
  case ErrorCode_E_SNAPSHOT_RUNNING_JOBS: return "E_SNAPSHOT_RUNNING_JOBS"
  case ErrorCode_E_SNAPSHOT_NOT_FOUND: return "E_SNAPSHOT_NOT_FOUND"
  case ErrorCode_E_BLOCK_WRITE_FAILURE: return "E_BLOCK_WRITE_FAILURE"
  case ErrorCode_E_REBUILD_INDEX_FAILURE: return "E_REBUILD_INDEX_FAILURE"
  case ErrorCode_E_INDEX_WITH_TTL: return "E_INDEX_WITH_TTL"
  case ErrorCode_E_ADD_JOB_FAILURE: return "E_ADD_JOB_FAILURE"
  case ErrorCode_E_STOP_JOB_FAILURE: return "E_STOP_JOB_FAILURE"
  case ErrorCode_E_SAVE_JOB_FAILURE: return "E_SAVE_JOB_FAILURE"
  case ErrorCode_E_BALANCER_FAILURE: return "E_BALANCER_FAILURE"
  case ErrorCode_E_JOB_NOT_FINISHED: return "E_JOB_NOT_FINISHED"
  case ErrorCode_E_TASK_REPORT_OUT_DATE: return "E_TASK_REPORT_OUT_DATE"
  case ErrorCode_E_JOB_NOT_IN_SPACE: return "E_JOB_NOT_IN_SPACE"
  case ErrorCode_E_JOB_NEED_RECOVER: return "E_JOB_NEED_RECOVER"
  case ErrorCode_E_JOB_ALREADY_FINISH: return "E_JOB_ALREADY_FINISH"
  case ErrorCode_E_JOB_SUBMITTED: return "E_JOB_SUBMITTED"
  case ErrorCode_E_JOB_NOT_STOPPABLE: return "E_JOB_NOT_STOPPABLE"
  case ErrorCode_E_JOB_HAS_NO_TARGET_STORAGE: return "E_JOB_HAS_NO_TARGET_STORAGE"
  case ErrorCode_E_INVALID_JOB: return "E_INVALID_JOB"
  case ErrorCode_E_BACKUP_RUNNING_JOBS: return "E_BACKUP_RUNNING_JOBS"
  case ErrorCode_E_BACKUP_SPACE_NOT_FOUND: return "E_BACKUP_SPACE_NOT_FOUND"
  case ErrorCode_E_RESTORE_FAILURE: return "E_RESTORE_FAILURE"
  case ErrorCode_E_SESSION_NOT_FOUND: return "E_SESSION_NOT_FOUND"
  case ErrorCode_E_LIST_CLUSTER_FAILURE: return "E_LIST_CLUSTER_FAILURE"
  case ErrorCode_E_LIST_CLUSTER_GET_ABS_PATH_FAILURE: return "E_LIST_CLUSTER_GET_ABS_PATH_FAILURE"
  case ErrorCode_E_LIST_CLUSTER_NO_AGENT_FAILURE: return "E_LIST_CLUSTER_NO_AGENT_FAILURE"
  case ErrorCode_E_QUERY_NOT_FOUND: return "E_QUERY_NOT_FOUND"
  case ErrorCode_E_AGENT_HB_FAILUE: return "E_AGENT_HB_FAILUE"
  case ErrorCode_E_INVALID_VARIABLE: return "E_INVALID_VARIABLE"
  case ErrorCode_E_VARIABLE_TYPE_VALUE_MISMATCH: return "E_VARIABLE_TYPE_VALUE_MISMATCH"
  case ErrorCode_E_HOST_CAN_NOT_BE_ADDED: return "E_HOST_CAN_NOT_BE_ADDED"
  case ErrorCode_E_ACCESS_ES_FAILURE: return "E_ACCESS_ES_FAILURE"
  case ErrorCode_E_GRAPH_MEMORY_EXCEEDED: return "E_GRAPH_MEMORY_EXCEEDED"
  case ErrorCode_E_CONSENSUS_ERROR: return "E_CONSENSUS_ERROR"
  case ErrorCode_E_KEY_HAS_EXISTS: return "E_KEY_HAS_EXISTS"
  case ErrorCode_E_DATA_TYPE_MISMATCH: return "E_DATA_TYPE_MISMATCH"
  case ErrorCode_E_INVALID_FIELD_VALUE: return "E_INVALID_FIELD_VALUE"
  case ErrorCode_E_INVALID_OPERATION: return "E_INVALID_OPERATION"
  case ErrorCode_E_NOT_NULLABLE: return "E_NOT_NULLABLE"
  case ErrorCode_E_FIELD_UNSET: return "E_FIELD_UNSET"
  case ErrorCode_E_OUT_OF_RANGE: return "E_OUT_OF_RANGE"
  case ErrorCode_E_DATA_CONFLICT_ERROR: return "E_DATA_CONFLICT_ERROR"
  case ErrorCode_E_WRITE_STALLED: return "E_WRITE_STALLED"
  case ErrorCode_E_IMPROPER_DATA_TYPE: return "E_IMPROPER_DATA_TYPE"
  case ErrorCode_E_INVALID_SPACEVIDLEN: return "E_INVALID_SPACEVIDLEN"
  case ErrorCode_E_INVALID_FILTER: return "E_INVALID_FILTER"
  case ErrorCode_E_INVALID_UPDATER: return "E_INVALID_UPDATER"
  case ErrorCode_E_INVALID_STORE: return "E_INVALID_STORE"
  case ErrorCode_E_INVALID_PEER: return "E_INVALID_PEER"
  case ErrorCode_E_RETRY_EXHAUSTED: return "E_RETRY_EXHAUSTED"
  case ErrorCode_E_TRANSFER_LEADER_FAILED: return "E_TRANSFER_LEADER_FAILED"
  case ErrorCode_E_INVALID_STAT_TYPE: return "E_INVALID_STAT_TYPE"
  case ErrorCode_E_INVALID_VID: return "E_INVALID_VID"
  case ErrorCode_E_NO_TRANSFORMED: return "E_NO_TRANSFORMED"
  case ErrorCode_E_LOAD_META_FAILED: return "E_LOAD_META_FAILED"
  case ErrorCode_E_FAILED_TO_CHECKPOINT: return "E_FAILED_TO_CHECKPOINT"
  case ErrorCode_E_CHECKPOINT_BLOCKED: return "E_CHECKPOINT_BLOCKED"
  case ErrorCode_E_FILTER_OUT: return "E_FILTER_OUT"
  case ErrorCode_E_INVALID_DATA: return "E_INVALID_DATA"
  case ErrorCode_E_MUTATE_EDGE_CONFLICT: return "E_MUTATE_EDGE_CONFLICT"
  case ErrorCode_E_MUTATE_TAG_CONFLICT: return "E_MUTATE_TAG_CONFLICT"
  case ErrorCode_E_OUTDATED_LOCK: return "E_OUTDATED_LOCK"
  case ErrorCode_E_INVALID_TASK_PARA: return "E_INVALID_TASK_PARA"
  case ErrorCode_E_USER_CANCEL: return "E_USER_CANCEL"
  case ErrorCode_E_TASK_EXECUTION_FAILED: return "E_TASK_EXECUTION_FAILED"
  case ErrorCode_E_PLAN_IS_KILLED: return "E_PLAN_IS_KILLED"
  case ErrorCode_E_NO_TERM: return "E_NO_TERM"
  case ErrorCode_E_OUTDATED_TERM: return "E_OUTDATED_TERM"
  case ErrorCode_E_OUTDATED_EDGE: return "E_OUTDATED_EDGE"
  case ErrorCode_E_WRITE_WRITE_CONFLICT: return "E_WRITE_WRITE_CONFLICT"
  case ErrorCode_E_CLIENT_SERVER_INCOMPATIBLE: return "E_CLIENT_SERVER_INCOMPATIBLE"
  case ErrorCode_E_ID_FAILED: return "E_ID_FAILED"
  case ErrorCode_E_RAFT_UNKNOWN_PART: return "E_RAFT_UNKNOWN_PART"
  case ErrorCode_E_RAFT_LOG_GAP: return "E_RAFT_LOG_GAP"
  case ErrorCode_E_RAFT_LOG_STALE: return "E_RAFT_LOG_STALE"
  case ErrorCode_E_RAFT_TERM_OUT_OF_DATE: return "E_RAFT_TERM_OUT_OF_DATE"
  case ErrorCode_E_RAFT_UNKNOWN_APPEND_LOG: return "E_RAFT_UNKNOWN_APPEND_LOG"
  case ErrorCode_E_RAFT_WAITING_SNAPSHOT: return "E_RAFT_WAITING_SNAPSHOT"
  case ErrorCode_E_RAFT_SENDING_SNAPSHOT: return "E_RAFT_SENDING_SNAPSHOT"
  case ErrorCode_E_RAFT_INVALID_PEER: return "E_RAFT_INVALID_PEER"
  case ErrorCode_E_RAFT_NOT_READY: return "E_RAFT_NOT_READY"
  case ErrorCode_E_RAFT_STOPPED: return "E_RAFT_STOPPED"
  case ErrorCode_E_RAFT_BAD_ROLE: return "E_RAFT_BAD_ROLE"
  case ErrorCode_E_RAFT_WAL_FAIL: return "E_RAFT_WAL_FAIL"
  case ErrorCode_E_RAFT_HOST_STOPPED: return "E_RAFT_HOST_STOPPED"
  case ErrorCode_E_RAFT_TOO_MANY_REQUESTS: return "E_RAFT_TOO_MANY_REQUESTS"
  case ErrorCode_E_RAFT_PERSIST_SNAPSHOT_FAILED: return "E_RAFT_PERSIST_SNAPSHOT_FAILED"
  case ErrorCode_E_RAFT_RPC_EXCEPTION: return "E_RAFT_RPC_EXCEPTION"
  case ErrorCode_E_RAFT_NO_WAL_FOUND: return "E_RAFT_NO_WAL_FOUND"
  case ErrorCode_E_RAFT_HOST_PAUSED: return "E_RAFT_HOST_PAUSED"
  case ErrorCode_E_RAFT_WRITE_BLOCKED: return "E_RAFT_WRITE_BLOCKED"
  case ErrorCode_E_RAFT_BUFFER_OVERFLOW: return "E_RAFT_BUFFER_OVERFLOW"
  case ErrorCode_E_RAFT_ATOMIC_OP_FAILED: return "E_RAFT_ATOMIC_OP_FAILED"
  case ErrorCode_E_LEADER_LEASE_FAILED: return "E_LEADER_LEASE_FAILED"
  case ErrorCode_E_RAFT_CAUGHT_UP: return "E_RAFT_CAUGHT_UP"
  case ErrorCode_E_LOG_GAP: return "E_LOG_GAP"
  case ErrorCode_E_LOG_STALE: return "E_LOG_STALE"
  case ErrorCode_E_INVALID_DRAINER_STORE: return "E_INVALID_DRAINER_STORE"
  case ErrorCode_E_SPACE_MISMATCH: return "E_SPACE_MISMATCH"
  case ErrorCode_E_PART_MISMATCH: return "E_PART_MISMATCH"
  case ErrorCode_E_DATA_CONFLICT: return "E_DATA_CONFLICT"
  case ErrorCode_E_REQ_CONFLICT: return "E_REQ_CONFLICT"
  case ErrorCode_E_DATA_ILLEGAL: return "E_DATA_ILLEGAL"
  case ErrorCode_E_CACHE_CONFIG_ERROR: return "E_CACHE_CONFIG_ERROR"
  case ErrorCode_E_NOT_ENOUGH_SPACE: return "E_NOT_ENOUGH_SPACE"
  case ErrorCode_E_CACHE_MISS: return "E_CACHE_MISS"
  case ErrorCode_E_POOL_NOT_FOUND: return "E_POOL_NOT_FOUND"
  case ErrorCode_E_CACHE_WRITE_FAILURE: return "E_CACHE_WRITE_FAILURE"
  case ErrorCode_E_NODE_NUMBER_EXCEED_LIMIT: return "E_NODE_NUMBER_EXCEED_LIMIT"
  case ErrorCode_E_PARSING_LICENSE_FAILURE: return "E_PARSING_LICENSE_FAILURE"
  case ErrorCode_E_STORAGE_MEMORY_EXCEEDED: return "E_STORAGE_MEMORY_EXCEEDED"
  case ErrorCode_E_UNKNOWN: return "E_UNKNOWN"
  }
  return "<UNSET>"
}

func ErrorCodeFromString(s string) (ErrorCode, error) {
  switch s {
  case "SUCCEEDED": return ErrorCode_SUCCEEDED, nil 
  case "E_DISCONNECTED": return ErrorCode_E_DISCONNECTED, nil 
  case "E_FAIL_TO_CONNECT": return ErrorCode_E_FAIL_TO_CONNECT, nil 
  case "E_RPC_FAILURE": return ErrorCode_E_RPC_FAILURE, nil 
  case "E_LEADER_CHANGED": return ErrorCode_E_LEADER_CHANGED, nil 
  case "E_SPACE_NOT_FOUND": return ErrorCode_E_SPACE_NOT_FOUND, nil 
  case "E_TAG_NOT_FOUND": return ErrorCode_E_TAG_NOT_FOUND, nil 
  case "E_EDGE_NOT_FOUND": return ErrorCode_E_EDGE_NOT_FOUND, nil 
  case "E_INDEX_NOT_FOUND": return ErrorCode_E_INDEX_NOT_FOUND, nil 
  case "E_EDGE_PROP_NOT_FOUND": return ErrorCode_E_EDGE_PROP_NOT_FOUND, nil 
  case "E_TAG_PROP_NOT_FOUND": return ErrorCode_E_TAG_PROP_NOT_FOUND, nil 
  case "E_ROLE_NOT_FOUND": return ErrorCode_E_ROLE_NOT_FOUND, nil 
  case "E_CONFIG_NOT_FOUND": return ErrorCode_E_CONFIG_NOT_FOUND, nil 
  case "E_MACHINE_NOT_FOUND": return ErrorCode_E_MACHINE_NOT_FOUND, nil 
  case "E_ZONE_NOT_FOUND": return ErrorCode_E_ZONE_NOT_FOUND, nil 
  case "E_LISTENER_NOT_FOUND": return ErrorCode_E_LISTENER_NOT_FOUND, nil 
  case "E_PART_NOT_FOUND": return ErrorCode_E_PART_NOT_FOUND, nil 
  case "E_KEY_NOT_FOUND": return ErrorCode_E_KEY_NOT_FOUND, nil 
  case "E_USER_NOT_FOUND": return ErrorCode_E_USER_NOT_FOUND, nil 
  case "E_STATS_NOT_FOUND": return ErrorCode_E_STATS_NOT_FOUND, nil 
  case "E_SERVICE_NOT_FOUND": return ErrorCode_E_SERVICE_NOT_FOUND, nil 
  case "E_DRAINER_NOT_FOUND": return ErrorCode_E_DRAINER_NOT_FOUND, nil 
  case "E_DRAINER_CLIENT_NOT_FOUND": return ErrorCode_E_DRAINER_CLIENT_NOT_FOUND, nil 
  case "E_PART_STOPPED": return ErrorCode_E_PART_STOPPED, nil 
  case "E_BACKUP_FAILED": return ErrorCode_E_BACKUP_FAILED, nil 
  case "E_BACKUP_EMPTY_TABLE": return ErrorCode_E_BACKUP_EMPTY_TABLE, nil 
  case "E_BACKUP_TABLE_FAILED": return ErrorCode_E_BACKUP_TABLE_FAILED, nil 
  case "E_PARTIAL_RESULT": return ErrorCode_E_PARTIAL_RESULT, nil 
  case "E_REBUILD_INDEX_FAILED": return ErrorCode_E_REBUILD_INDEX_FAILED, nil 
  case "E_INVALID_PASSWORD": return ErrorCode_E_INVALID_PASSWORD, nil 
  case "E_FAILED_GET_ABS_PATH": return ErrorCode_E_FAILED_GET_ABS_PATH, nil 
  case "E_LISTENER_PROGRESS_FAILED": return ErrorCode_E_LISTENER_PROGRESS_FAILED, nil 
  case "E_SYNC_LISTENER_NOT_FOUND": return ErrorCode_E_SYNC_LISTENER_NOT_FOUND, nil 
  case "E_DRAINER_PROGRESS_FAILED": return ErrorCode_E_DRAINER_PROGRESS_FAILED, nil 
  case "E_PART_DISABLED": return ErrorCode_E_PART_DISABLED, nil 
  case "E_PART_ALREADY_STARTED": return ErrorCode_E_PART_ALREADY_STARTED, nil 
  case "E_PART_ALREADY_STOPPED": return ErrorCode_E_PART_ALREADY_STOPPED, nil 
  case "E_BAD_USERNAME_PASSWORD": return ErrorCode_E_BAD_USERNAME_PASSWORD, nil 
  case "E_SESSION_INVALID": return ErrorCode_E_SESSION_INVALID, nil 
  case "E_SESSION_TIMEOUT": return ErrorCode_E_SESSION_TIMEOUT, nil 
  case "E_SYNTAX_ERROR": return ErrorCode_E_SYNTAX_ERROR, nil 
  case "E_EXECUTION_ERROR": return ErrorCode_E_EXECUTION_ERROR, nil 
  case "E_STATEMENT_EMPTY": return ErrorCode_E_STATEMENT_EMPTY, nil 
  case "E_BAD_PERMISSION": return ErrorCode_E_BAD_PERMISSION, nil 
  case "E_SEMANTIC_ERROR": return ErrorCode_E_SEMANTIC_ERROR, nil 
  case "E_TOO_MANY_CONNECTIONS": return ErrorCode_E_TOO_MANY_CONNECTIONS, nil 
  case "E_PARTIAL_SUCCEEDED": return ErrorCode_E_PARTIAL_SUCCEEDED, nil 
  case "E_NO_HOSTS": return ErrorCode_E_NO_HOSTS, nil 
  case "E_EXISTED": return ErrorCode_E_EXISTED, nil 
  case "E_INVALID_HOST": return ErrorCode_E_INVALID_HOST, nil 
  case "E_UNSUPPORTED": return ErrorCode_E_UNSUPPORTED, nil 
  case "E_NOT_DROP": return ErrorCode_E_NOT_DROP, nil 
  case "E_BALANCER_RUNNING": return ErrorCode_E_BALANCER_RUNNING, nil 
  case "E_CONFIG_IMMUTABLE": return ErrorCode_E_CONFIG_IMMUTABLE, nil 
  case "E_CONFLICT": return ErrorCode_E_CONFLICT, nil 
  case "E_INVALID_PARM": return ErrorCode_E_INVALID_PARM, nil 
  case "E_WRONGCLUSTER": return ErrorCode_E_WRONGCLUSTER, nil 
  case "E_ZONE_NOT_ENOUGH": return ErrorCode_E_ZONE_NOT_ENOUGH, nil 
  case "E_ZONE_IS_EMPTY": return ErrorCode_E_ZONE_IS_EMPTY, nil 
  case "E_LISTENER_CONFLICT": return ErrorCode_E_LISTENER_CONFLICT, nil 
  case "E_SCHEMA_NAME_EXISTS": return ErrorCode_E_SCHEMA_NAME_EXISTS, nil 
  case "E_RELATED_INDEX_EXISTS": return ErrorCode_E_RELATED_INDEX_EXISTS, nil 
  case "E_RELATED_SPACE_EXISTS": return ErrorCode_E_RELATED_SPACE_EXISTS, nil 
  case "E_RELATED_FULLTEXT_INDEX_EXISTS": return ErrorCode_E_RELATED_FULLTEXT_INDEX_EXISTS, nil 
  case "E_HISTORY_CONFLICT": return ErrorCode_E_HISTORY_CONFLICT, nil 
  case "E_STORE_FAILURE": return ErrorCode_E_STORE_FAILURE, nil 
  case "E_STORE_SEGMENT_ILLEGAL": return ErrorCode_E_STORE_SEGMENT_ILLEGAL, nil 
  case "E_BAD_BALANCE_PLAN": return ErrorCode_E_BAD_BALANCE_PLAN, nil 
  case "E_BALANCED": return ErrorCode_E_BALANCED, nil 
  case "E_NO_RUNNING_BALANCE_PLAN": return ErrorCode_E_NO_RUNNING_BALANCE_PLAN, nil 
  case "E_NO_VALID_HOST": return ErrorCode_E_NO_VALID_HOST, nil 
  case "E_CORRUPTED_BALANCE_PLAN": return ErrorCode_E_CORRUPTED_BALANCE_PLAN, nil 
  case "E_NO_INVALID_BALANCE_PLAN": return ErrorCode_E_NO_INVALID_BALANCE_PLAN, nil 
  case "E_NO_VALID_DRAINER": return ErrorCode_E_NO_VALID_DRAINER, nil 
  case "E_IMPROPER_ROLE": return ErrorCode_E_IMPROPER_ROLE, nil 
  case "E_INVALID_PARTITION_NUM": return ErrorCode_E_INVALID_PARTITION_NUM, nil 
  case "E_INVALID_REPLICA_FACTOR": return ErrorCode_E_INVALID_REPLICA_FACTOR, nil 
  case "E_INVALID_CHARSET": return ErrorCode_E_INVALID_CHARSET, nil 
  case "E_INVALID_COLLATE": return ErrorCode_E_INVALID_COLLATE, nil 
  case "E_CHARSET_COLLATE_NOT_MATCH": return ErrorCode_E_CHARSET_COLLATE_NOT_MATCH, nil 
  case "E_PRIVILEGE_ALL_TAG_EDGE_SETTLED": return ErrorCode_E_PRIVILEGE_ALL_TAG_EDGE_SETTLED, nil 
  case "E_PRIVILEGE_NOT_EXIST": return ErrorCode_E_PRIVILEGE_NOT_EXIST, nil 
  case "E_PRIVILEGE_NEED_BASIC_ROLE": return ErrorCode_E_PRIVILEGE_NEED_BASIC_ROLE, nil 
  case "E_PRIVILEGE_ACTION_INVALID": return ErrorCode_E_PRIVILEGE_ACTION_INVALID, nil 
  case "E_SNAPSHOT_FAILURE": return ErrorCode_E_SNAPSHOT_FAILURE, nil 
  case "E_SNAPSHOT_RUNNING_JOBS": return ErrorCode_E_SNAPSHOT_RUNNING_JOBS, nil 
  case "E_SNAPSHOT_NOT_FOUND": return ErrorCode_E_SNAPSHOT_NOT_FOUND, nil 
  case "E_BLOCK_WRITE_FAILURE": return ErrorCode_E_BLOCK_WRITE_FAILURE, nil 
  case "E_REBUILD_INDEX_FAILURE": return ErrorCode_E_REBUILD_INDEX_FAILURE, nil 
  case "E_INDEX_WITH_TTL": return ErrorCode_E_INDEX_WITH_TTL, nil 
  case "E_ADD_JOB_FAILURE": return ErrorCode_E_ADD_JOB_FAILURE, nil 
  case "E_STOP_JOB_FAILURE": return ErrorCode_E_STOP_JOB_FAILURE, nil 
  case "E_SAVE_JOB_FAILURE": return ErrorCode_E_SAVE_JOB_FAILURE, nil 
  case "E_BALANCER_FAILURE": return ErrorCode_E_BALANCER_FAILURE, nil 
  case "E_JOB_NOT_FINISHED": return ErrorCode_E_JOB_NOT_FINISHED, nil 
  case "E_TASK_REPORT_OUT_DATE": return ErrorCode_E_TASK_REPORT_OUT_DATE, nil 
  case "E_JOB_NOT_IN_SPACE": return ErrorCode_E_JOB_NOT_IN_SPACE, nil 
  case "E_JOB_NEED_RECOVER": return ErrorCode_E_JOB_NEED_RECOVER, nil 
  case "E_JOB_ALREADY_FINISH": return ErrorCode_E_JOB_ALREADY_FINISH, nil 
  case "E_JOB_SUBMITTED": return ErrorCode_E_JOB_SUBMITTED, nil 
  case "E_JOB_NOT_STOPPABLE": return ErrorCode_E_JOB_NOT_STOPPABLE, nil 
  case "E_JOB_HAS_NO_TARGET_STORAGE": return ErrorCode_E_JOB_HAS_NO_TARGET_STORAGE, nil 
  case "E_INVALID_JOB": return ErrorCode_E_INVALID_JOB, nil 
  case "E_BACKUP_RUNNING_JOBS": return ErrorCode_E_BACKUP_RUNNING_JOBS, nil 
  case "E_BACKUP_SPACE_NOT_FOUND": return ErrorCode_E_BACKUP_SPACE_NOT_FOUND, nil 
  case "E_RESTORE_FAILURE": return ErrorCode_E_RESTORE_FAILURE, nil 
  case "E_SESSION_NOT_FOUND": return ErrorCode_E_SESSION_NOT_FOUND, nil 
  case "E_LIST_CLUSTER_FAILURE": return ErrorCode_E_LIST_CLUSTER_FAILURE, nil 
  case "E_LIST_CLUSTER_GET_ABS_PATH_FAILURE": return ErrorCode_E_LIST_CLUSTER_GET_ABS_PATH_FAILURE, nil 
  case "E_LIST_CLUSTER_NO_AGENT_FAILURE": return ErrorCode_E_LIST_CLUSTER_NO_AGENT_FAILURE, nil 
  case "E_QUERY_NOT_FOUND": return ErrorCode_E_QUERY_NOT_FOUND, nil 
  case "E_AGENT_HB_FAILUE": return ErrorCode_E_AGENT_HB_FAILUE, nil 
  case "E_INVALID_VARIABLE": return ErrorCode_E_INVALID_VARIABLE, nil 
  case "E_VARIABLE_TYPE_VALUE_MISMATCH": return ErrorCode_E_VARIABLE_TYPE_VALUE_MISMATCH, nil 
  case "E_HOST_CAN_NOT_BE_ADDED": return ErrorCode_E_HOST_CAN_NOT_BE_ADDED, nil 
  case "E_ACCESS_ES_FAILURE": return ErrorCode_E_ACCESS_ES_FAILURE, nil 
  case "E_GRAPH_MEMORY_EXCEEDED": return ErrorCode_E_GRAPH_MEMORY_EXCEEDED, nil 
  case "E_CONSENSUS_ERROR": return ErrorCode_E_CONSENSUS_ERROR, nil 
  case "E_KEY_HAS_EXISTS": return ErrorCode_E_KEY_HAS_EXISTS, nil 
  case "E_DATA_TYPE_MISMATCH": return ErrorCode_E_DATA_TYPE_MISMATCH, nil 
  case "E_INVALID_FIELD_VALUE": return ErrorCode_E_INVALID_FIELD_VALUE, nil 
  case "E_INVALID_OPERATION": return ErrorCode_E_INVALID_OPERATION, nil 
  case "E_NOT_NULLABLE": return ErrorCode_E_NOT_NULLABLE, nil 
  case "E_FIELD_UNSET": return ErrorCode_E_FIELD_UNSET, nil 
  case "E_OUT_OF_RANGE": return ErrorCode_E_OUT_OF_RANGE, nil 
  case "E_DATA_CONFLICT_ERROR": return ErrorCode_E_DATA_CONFLICT_ERROR, nil 
  case "E_WRITE_STALLED": return ErrorCode_E_WRITE_STALLED, nil 
  case "E_IMPROPER_DATA_TYPE": return ErrorCode_E_IMPROPER_DATA_TYPE, nil 
  case "E_INVALID_SPACEVIDLEN": return ErrorCode_E_INVALID_SPACEVIDLEN, nil 
  case "E_INVALID_FILTER": return ErrorCode_E_INVALID_FILTER, nil 
  case "E_INVALID_UPDATER": return ErrorCode_E_INVALID_UPDATER, nil 
  case "E_INVALID_STORE": return ErrorCode_E_INVALID_STORE, nil 
  case "E_INVALID_PEER": return ErrorCode_E_INVALID_PEER, nil 
  case "E_RETRY_EXHAUSTED": return ErrorCode_E_RETRY_EXHAUSTED, nil 
  case "E_TRANSFER_LEADER_FAILED": return ErrorCode_E_TRANSFER_LEADER_FAILED, nil 
  case "E_INVALID_STAT_TYPE": return ErrorCode_E_INVALID_STAT_TYPE, nil 
  case "E_INVALID_VID": return ErrorCode_E_INVALID_VID, nil 
  case "E_NO_TRANSFORMED": return ErrorCode_E_NO_TRANSFORMED, nil 
  case "E_LOAD_META_FAILED": return ErrorCode_E_LOAD_META_FAILED, nil 
  case "E_FAILED_TO_CHECKPOINT": return ErrorCode_E_FAILED_TO_CHECKPOINT, nil 
  case "E_CHECKPOINT_BLOCKED": return ErrorCode_E_CHECKPOINT_BLOCKED, nil 
  case "E_FILTER_OUT": return ErrorCode_E_FILTER_OUT, nil 
  case "E_INVALID_DATA": return ErrorCode_E_INVALID_DATA, nil 
  case "E_MUTATE_EDGE_CONFLICT": return ErrorCode_E_MUTATE_EDGE_CONFLICT, nil 
  case "E_MUTATE_TAG_CONFLICT": return ErrorCode_E_MUTATE_TAG_CONFLICT, nil 
  case "E_OUTDATED_LOCK": return ErrorCode_E_OUTDATED_LOCK, nil 
  case "E_INVALID_TASK_PARA": return ErrorCode_E_INVALID_TASK_PARA, nil 
  case "E_USER_CANCEL": return ErrorCode_E_USER_CANCEL, nil 
  case "E_TASK_EXECUTION_FAILED": return ErrorCode_E_TASK_EXECUTION_FAILED, nil 
  case "E_PLAN_IS_KILLED": return ErrorCode_E_PLAN_IS_KILLED, nil 
  case "E_NO_TERM": return ErrorCode_E_NO_TERM, nil 
  case "E_OUTDATED_TERM": return ErrorCode_E_OUTDATED_TERM, nil 
  case "E_OUTDATED_EDGE": return ErrorCode_E_OUTDATED_EDGE, nil 
  case "E_WRITE_WRITE_CONFLICT": return ErrorCode_E_WRITE_WRITE_CONFLICT, nil 
  case "E_CLIENT_SERVER_INCOMPATIBLE": return ErrorCode_E_CLIENT_SERVER_INCOMPATIBLE, nil 
  case "E_ID_FAILED": return ErrorCode_E_ID_FAILED, nil 
  case "E_RAFT_UNKNOWN_PART": return ErrorCode_E_RAFT_UNKNOWN_PART, nil 
  case "E_RAFT_LOG_GAP": return ErrorCode_E_RAFT_LOG_GAP, nil 
  case "E_RAFT_LOG_STALE": return ErrorCode_E_RAFT_LOG_STALE, nil 
  case "E_RAFT_TERM_OUT_OF_DATE": return ErrorCode_E_RAFT_TERM_OUT_OF_DATE, nil 
  case "E_RAFT_UNKNOWN_APPEND_LOG": return ErrorCode_E_RAFT_UNKNOWN_APPEND_LOG, nil 
  case "E_RAFT_WAITING_SNAPSHOT": return ErrorCode_E_RAFT_WAITING_SNAPSHOT, nil 
  case "E_RAFT_SENDING_SNAPSHOT": return ErrorCode_E_RAFT_SENDING_SNAPSHOT, nil 
  case "E_RAFT_INVALID_PEER": return ErrorCode_E_RAFT_INVALID_PEER, nil 
  case "E_RAFT_NOT_READY": return ErrorCode_E_RAFT_NOT_READY, nil 
  case "E_RAFT_STOPPED": return ErrorCode_E_RAFT_STOPPED, nil 
  case "E_RAFT_BAD_ROLE": return ErrorCode_E_RAFT_BAD_ROLE, nil 
  case "E_RAFT_WAL_FAIL": return ErrorCode_E_RAFT_WAL_FAIL, nil 
  case "E_RAFT_HOST_STOPPED": return ErrorCode_E_RAFT_HOST_STOPPED, nil 
  case "E_RAFT_TOO_MANY_REQUESTS": return ErrorCode_E_RAFT_TOO_MANY_REQUESTS, nil 
  case "E_RAFT_PERSIST_SNAPSHOT_FAILED": return ErrorCode_E_RAFT_PERSIST_SNAPSHOT_FAILED, nil 
  case "E_RAFT_RPC_EXCEPTION": return ErrorCode_E_RAFT_RPC_EXCEPTION, nil 
  case "E_RAFT_NO_WAL_FOUND": return ErrorCode_E_RAFT_NO_WAL_FOUND, nil 
  case "E_RAFT_HOST_PAUSED": return ErrorCode_E_RAFT_HOST_PAUSED, nil 
  case "E_RAFT_WRITE_BLOCKED": return ErrorCode_E_RAFT_WRITE_BLOCKED, nil 
  case "E_RAFT_BUFFER_OVERFLOW": return ErrorCode_E_RAFT_BUFFER_OVERFLOW, nil 
  case "E_RAFT_ATOMIC_OP_FAILED": return ErrorCode_E_RAFT_ATOMIC_OP_FAILED, nil 
  case "E_LEADER_LEASE_FAILED": return ErrorCode_E_LEADER_LEASE_FAILED, nil 
  case "E_RAFT_CAUGHT_UP": return ErrorCode_E_RAFT_CAUGHT_UP, nil 
  case "E_LOG_GAP": return ErrorCode_E_LOG_GAP, nil 
  case "E_LOG_STALE": return ErrorCode_E_LOG_STALE, nil 
  case "E_INVALID_DRAINER_STORE": return ErrorCode_E_INVALID_DRAINER_STORE, nil 
  case "E_SPACE_MISMATCH": return ErrorCode_E_SPACE_MISMATCH, nil 
  case "E_PART_MISMATCH": return ErrorCode_E_PART_MISMATCH, nil 
  case "E_DATA_CONFLICT": return ErrorCode_E_DATA_CONFLICT, nil 
  case "E_REQ_CONFLICT": return ErrorCode_E_REQ_CONFLICT, nil 
  case "E_DATA_ILLEGAL": return ErrorCode_E_DATA_ILLEGAL, nil 
  case "E_CACHE_CONFIG_ERROR": return ErrorCode_E_CACHE_CONFIG_ERROR, nil 
  case "E_NOT_ENOUGH_SPACE": return ErrorCode_E_NOT_ENOUGH_SPACE, nil 
  case "E_CACHE_MISS": return ErrorCode_E_CACHE_MISS, nil 
  case "E_POOL_NOT_FOUND": return ErrorCode_E_POOL_NOT_FOUND, nil 
  case "E_CACHE_WRITE_FAILURE": return ErrorCode_E_CACHE_WRITE_FAILURE, nil 
  case "E_NODE_NUMBER_EXCEED_LIMIT": return ErrorCode_E_NODE_NUMBER_EXCEED_LIMIT, nil 
  case "E_PARSING_LICENSE_FAILURE": return ErrorCode_E_PARSING_LICENSE_FAILURE, nil 
  case "E_STORAGE_MEMORY_EXCEEDED": return ErrorCode_E_STORAGE_MEMORY_EXCEEDED, nil 
  case "E_UNKNOWN": return ErrorCode_E_UNKNOWN, nil 
  }
  return ErrorCode(0), fmt.Errorf("not a valid ErrorCode string")
}


func ErrorCodePtr(v ErrorCode) *ErrorCode { return &v }

func (p ErrorCode) MarshalText() ([]byte, error) {
return []byte(p.String()), nil
}

func (p *ErrorCode) UnmarshalText(text []byte) error {
q, err := ErrorCodeFromString(string(text))
if (err != nil) {
return err
}
*p = q
return nil
}

func (p *ErrorCode) Scan(value interface{}) error {
v, ok := value.(int64)
if !ok {
return errors.New("Scan value is not int64")
}
*p = ErrorCode(v)
return nil
}

func (p * ErrorCode) Value() (driver.Value, error) {
  if p == nil {
    return nil, nil
  }
return int64(*p), nil
}
type ClusterID int64

func ClusterIDPtr(v ClusterID) *ClusterID { return &v }

type GraphSpaceID int32

func GraphSpaceIDPtr(v GraphSpaceID) *GraphSpaceID { return &v }

type PartitionID int32

func PartitionIDPtr(v PartitionID) *PartitionID { return &v }

type TagID int32

func TagIDPtr(v TagID) *TagID { return &v }

type EdgeType int32

func EdgeTypePtr(v EdgeType) *EdgeType { return &v }

type EdgeRanking int64

func EdgeRankingPtr(v EdgeRanking) *EdgeRanking { return &v }

type LogID int64

func LogIDPtr(v LogID) *LogID { return &v }

type TermID int64

func TermIDPtr(v TermID) *TermID { return &v }

type Timestamp int64

func TimestampPtr(v Timestamp) *Timestamp { return &v }

type IndexID int32

func IndexIDPtr(v IndexID) *IndexID { return &v }

type Port int32

func PortPtr(v Port) *Port { return &v }

type SessionID int64

func SessionIDPtr(v SessionID) *SessionID { return &v }

type ExecutionPlanID int64

func ExecutionPlanIDPtr(v ExecutionPlanID) *ExecutionPlanID { return &v }

// Attributes:
//  - TagID
//  - EdgeType
type SchemaID struct {
  TagID *TagID `thrift:"tag_id,1" db:"tag_id" json:"tag_id,omitempty"`
  EdgeType *EdgeType `thrift:"edge_type,2" db:"edge_type" json:"edge_type,omitempty"`
}

func NewSchemaID() *SchemaID {
  return &SchemaID{}
}

var SchemaID_TagID_DEFAULT TagID
func (p *SchemaID) GetTagID() TagID {
  if !p.IsSetTagID() {
    return SchemaID_TagID_DEFAULT
  }
return *p.TagID
}
var SchemaID_EdgeType_DEFAULT EdgeType
func (p *SchemaID) GetEdgeType() EdgeType {
  if !p.IsSetEdgeType() {
    return SchemaID_EdgeType_DEFAULT
  }
return *p.EdgeType
}
func (p *SchemaID) CountSetFieldsSchemaID() int {
  count := 0
  if (p.IsSetTagID()) {
    count++
  }
  if (p.IsSetEdgeType()) {
    count++
  }
  return count

}

func (p *SchemaID) IsSetTagID() bool {
  return p.TagID != nil
}

func (p *SchemaID) IsSetEdgeType() bool {
  return p.EdgeType != nil
}

func (p *SchemaID) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *SchemaID)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  temp := TagID(v)
  p.TagID = &temp
}
  return nil
}

func (p *SchemaID)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  temp := EdgeType(v)
  p.EdgeType = &temp
}
  return nil
}

func (p *SchemaID) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if c := p.CountSetFieldsSchemaID(); c != 1 {
    return fmt.Errorf("%T write union: exactly one field must be set (%d set)", p, c)
  }
  if err := oprot.WriteStructBegin(ctx, "SchemaID"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *SchemaID) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetTagID() {
    if err := oprot.WriteFieldBegin(ctx, "tag_id", thrift.I32, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:tag_id: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.TagID)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.tag_id (1) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:tag_id: ", p), err) }
  }
  return err
}

func (p *SchemaID) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetEdgeType() {
    if err := oprot.WriteFieldBegin(ctx, "edge_type", thrift.I32, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:edge_type: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.EdgeType)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.edge_type (2) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:edge_type: ", p), err) }
  }
  return err
}

func (p *SchemaID) Equals(other *SchemaID) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.TagID != other.TagID {
    if p.TagID == nil || other.TagID == nil {
      return false
    }
    if (*p.TagID) != (*other.TagID) { return false }
  }
  if p.EdgeType != other.EdgeType {
    if p.EdgeType == nil || other.EdgeType == nil {
      return false
    }
    if (*p.EdgeType) != (*other.EdgeType) { return false }
  }
  return true
}

func (p *SchemaID) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("SchemaID(%+v)", *p)
}

func (p *SchemaID) Validate() error {
  return nil
}
// Attributes:
//  - Year
//  - Month
//  - Day
type Date struct {
  Year int16 `thrift:"year,1" db:"year" json:"year"`
  Month int8 `thrift:"month,2" db:"month" json:"month"`
  Day int8 `thrift:"day,3" db:"day" json:"day"`
}

func NewDate() *Date {
  return &Date{}
}


func (p *Date) GetYear() int16 {
  return p.Year
}

func (p *Date) GetMonth() int8 {
  return p.Month
}

func (p *Date) GetDay() int8 {
  return p.Day
}
func (p *Date) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I16 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.BYTE {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.BYTE {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *Date)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI16(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Year = v
}
  return nil
}

func (p *Date)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadByte(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  temp := int8(v)
  p.Month = temp
}
  return nil
}

func (p *Date)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadByte(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  temp := int8(v)
  p.Day = temp
}
  return nil
}

func (p *Date) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "Date"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *Date) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "year", thrift.I16, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:year: ", p), err) }
  if err := oprot.WriteI16(ctx, int16(p.Year)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.year (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:year: ", p), err) }
  return err
}

func (p *Date) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "month", thrift.BYTE, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:month: ", p), err) }
  if err := oprot.WriteByte(ctx, int8(p.Month)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.month (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:month: ", p), err) }
  return err
}

func (p *Date) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "day", thrift.BYTE, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:day: ", p), err) }
  if err := oprot.WriteByte(ctx, int8(p.Day)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.day (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:day: ", p), err) }
  return err
}

func (p *Date) Equals(other *Date) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.Year != other.Year { return false }
  if p.Month != other.Month { return false }
  if p.Day != other.Day { return false }
  return true
}

func (p *Date) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("Date(%+v)", *p)
}

func (p *Date) Validate() error {
  return nil
}
// Attributes:
//  - Hour
//  - Minute
//  - Sec
//  - Microsec
type Time struct {
  Hour int8 `thrift:"hour,1" db:"hour" json:"hour"`
  Minute int8 `thrift:"minute,2" db:"minute" json:"minute"`
  Sec int8 `thrift:"sec,3" db:"sec" json:"sec"`
  Microsec int32 `thrift:"microsec,4" db:"microsec" json:"microsec"`
}

func NewTime() *Time {
  return &Time{}
}


func (p *Time) GetHour() int8 {
  return p.Hour
}

func (p *Time) GetMinute() int8 {
  return p.Minute
}

func (p *Time) GetSec() int8 {
  return p.Sec
}

func (p *Time) GetMicrosec() int32 {
  return p.Microsec
}
func (p *Time) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.BYTE {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.BYTE {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.BYTE {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *Time)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadByte(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  temp := int8(v)
  p.Hour = temp
}
  return nil
}

func (p *Time)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadByte(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  temp := int8(v)
  p.Minute = temp
}
  return nil
}

func (p *Time)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadByte(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  temp := int8(v)
  p.Sec = temp
}
  return nil
}

func (p *Time)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 4: ", err)
} else {
  p.Microsec = v
}
  return nil
}

func (p *Time) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "Time"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *Time) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "hour", thrift.BYTE, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:hour: ", p), err) }
  if err := oprot.WriteByte(ctx, int8(p.Hour)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.hour (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:hour: ", p), err) }
  return err
}

func (p *Time) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "minute", thrift.BYTE, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:minute: ", p), err) }
  if err := oprot.WriteByte(ctx, int8(p.Minute)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.minute (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:minute: ", p), err) }
  return err
}

func (p *Time) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "sec", thrift.BYTE, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:sec: ", p), err) }
  if err := oprot.WriteByte(ctx, int8(p.Sec)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.sec (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:sec: ", p), err) }
  return err
}

func (p *Time) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "microsec", thrift.I32, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:microsec: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.Microsec)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.microsec (4) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:microsec: ", p), err) }
  return err
}

func (p *Time) Equals(other *Time) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.Hour != other.Hour { return false }
  if p.Minute != other.Minute { return false }
  if p.Sec != other.Sec { return false }
  if p.Microsec != other.Microsec { return false }
  return true
}

func (p *Time) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("Time(%+v)", *p)
}

func (p *Time) Validate() error {
  return nil
}
// Attributes:
//  - Year
//  - Month
//  - Day
//  - Hour
//  - Minute
//  - Sec
//  - Microsec
type DateTime struct {
  Year int16 `thrift:"year,1" db:"year" json:"year"`
  Month int8 `thrift:"month,2" db:"month" json:"month"`
  Day int8 `thrift:"day,3" db:"day" json:"day"`
  Hour int8 `thrift:"hour,4" db:"hour" json:"hour"`
  Minute int8 `thrift:"minute,5" db:"minute" json:"minute"`
  Sec int8 `thrift:"sec,6" db:"sec" json:"sec"`
  Microsec int32 `thrift:"microsec,7" db:"microsec" json:"microsec"`
}

func NewDateTime() *DateTime {
  return &DateTime{}
}


func (p *DateTime) GetYear() int16 {
  return p.Year
}

func (p *DateTime) GetMonth() int8 {
  return p.Month
}

func (p *DateTime) GetDay() int8 {
  return p.Day
}

func (p *DateTime) GetHour() int8 {
  return p.Hour
}

func (p *DateTime) GetMinute() int8 {
  return p.Minute
}

func (p *DateTime) GetSec() int8 {
  return p.Sec
}

func (p *DateTime) GetMicrosec() int32 {
  return p.Microsec
}
func (p *DateTime) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I16 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.BYTE {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.BYTE {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.BYTE {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 5:
      if fieldTypeId == thrift.BYTE {
        if err := p.ReadField5(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 6:
      if fieldTypeId == thrift.BYTE {
        if err := p.ReadField6(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 7:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField7(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *DateTime)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI16(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Year = v
}
  return nil
}

func (p *DateTime)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadByte(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  temp := int8(v)
  p.Month = temp
}
  return nil
}

func (p *DateTime)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadByte(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  temp := int8(v)
  p.Day = temp
}
  return nil
}

func (p *DateTime)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadByte(ctx); err != nil {
  return thrift.PrependError("error reading field 4: ", err)
} else {
  temp := int8(v)
  p.Hour = temp
}
  return nil
}

func (p *DateTime)  ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadByte(ctx); err != nil {
  return thrift.PrependError("error reading field 5: ", err)
} else {
  temp := int8(v)
  p.Minute = temp
}
  return nil
}

func (p *DateTime)  ReadField6(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadByte(ctx); err != nil {
  return thrift.PrependError("error reading field 6: ", err)
} else {
  temp := int8(v)
  p.Sec = temp
}
  return nil
}

func (p *DateTime)  ReadField7(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 7: ", err)
} else {
  p.Microsec = v
}
  return nil
}

func (p *DateTime) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "DateTime"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
    if err := p.writeField5(ctx, oprot); err != nil { return err }
    if err := p.writeField6(ctx, oprot); err != nil { return err }
    if err := p.writeField7(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *DateTime) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "year", thrift.I16, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:year: ", p), err) }
  if err := oprot.WriteI16(ctx, int16(p.Year)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.year (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:year: ", p), err) }
  return err
}

func (p *DateTime) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "month", thrift.BYTE, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:month: ", p), err) }
  if err := oprot.WriteByte(ctx, int8(p.Month)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.month (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:month: ", p), err) }
  return err
}

func (p *DateTime) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "day", thrift.BYTE, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:day: ", p), err) }
  if err := oprot.WriteByte(ctx, int8(p.Day)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.day (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:day: ", p), err) }
  return err
}

func (p *DateTime) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "hour", thrift.BYTE, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:hour: ", p), err) }
  if err := oprot.WriteByte(ctx, int8(p.Hour)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.hour (4) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:hour: ", p), err) }
  return err
}

func (p *DateTime) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "minute", thrift.BYTE, 5); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:minute: ", p), err) }
  if err := oprot.WriteByte(ctx, int8(p.Minute)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.minute (5) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 5:minute: ", p), err) }
  return err
}

func (p *DateTime) writeField6(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "sec", thrift.BYTE, 6); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 6:sec: ", p), err) }
  if err := oprot.WriteByte(ctx, int8(p.Sec)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.sec (6) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 6:sec: ", p), err) }
  return err
}

func (p *DateTime) writeField7(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "microsec", thrift.I32, 7); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 7:microsec: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.Microsec)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.microsec (7) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 7:microsec: ", p), err) }
  return err
}

func (p *DateTime) Equals(other *DateTime) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.Year != other.Year { return false }
  if p.Month != other.Month { return false }
  if p.Day != other.Day { return false }
  if p.Hour != other.Hour { return false }
  if p.Minute != other.Minute { return false }
  if p.Sec != other.Sec { return false }
  if p.Microsec != other.Microsec { return false }
  return true
}

func (p *DateTime) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("DateTime(%+v)", *p)
}

func (p *DateTime) Validate() error {
  return nil
}
// Attributes:
//  - NVal
//  - BVal
//  - IVal
//  - FVal
//  - SVal
//  - DVal
//  - TVal
//  - DtVal
//  - VVal
//  - EVal
//  - PVal
//  - LVal
//  - MVal
//  - UVal
//  - GVal
//  - GgVal
//  - DuVal
type Value struct {
  NVal *NullType `thrift:"nVal,1" db:"nVal" json:"nVal,omitempty"`
  BVal *bool `thrift:"bVal,2" db:"bVal" json:"bVal,omitempty"`
  IVal *int64 `thrift:"iVal,3" db:"iVal" json:"iVal,omitempty"`
  FVal *float64 `thrift:"fVal,4" db:"fVal" json:"fVal,omitempty"`
  SVal []byte `thrift:"sVal,5" db:"sVal" json:"sVal,omitempty"`
  DVal *Date `thrift:"dVal,6" db:"dVal" json:"dVal,omitempty"`
  TVal *Time `thrift:"tVal,7" db:"tVal" json:"tVal,omitempty"`
  DtVal *DateTime `thrift:"dtVal,8" db:"dtVal" json:"dtVal,omitempty"`
  VVal *Vertex `thrift:"vVal,9" db:"vVal" json:"vVal,omitempty"`
  EVal *Edge `thrift:"eVal,10" db:"eVal" json:"eVal,omitempty"`
  PVal *Path `thrift:"pVal,11" db:"pVal" json:"pVal,omitempty"`
  LVal *NList `thrift:"lVal,12" db:"lVal" json:"lVal,omitempty"`
  MVal *NMap `thrift:"mVal,13" db:"mVal" json:"mVal,omitempty"`
  UVal *NSet `thrift:"uVal,14" db:"uVal" json:"uVal,omitempty"`
  GVal *DataSet `thrift:"gVal,15" db:"gVal" json:"gVal,omitempty"`
  GgVal *Geography `thrift:"ggVal,16" db:"ggVal" json:"ggVal,omitempty"`
  DuVal *Duration `thrift:"duVal,17" db:"duVal" json:"duVal,omitempty"`
}

func NewValue() *Value {
  return &Value{}
}

var Value_NVal_DEFAULT NullType
func (p *Value) GetNVal() NullType {
  if !p.IsSetNVal() {
    return Value_NVal_DEFAULT
  }
return *p.NVal
}
var Value_BVal_DEFAULT bool
func (p *Value) GetBVal() bool {
  if !p.IsSetBVal() {
    return Value_BVal_DEFAULT
  }
return *p.BVal
}
var Value_IVal_DEFAULT int64
func (p *Value) GetIVal() int64 {
  if !p.IsSetIVal() {
    return Value_IVal_DEFAULT
  }
return *p.IVal
}
var Value_FVal_DEFAULT float64
func (p *Value) GetFVal() float64 {
  if !p.IsSetFVal() {
    return Value_FVal_DEFAULT
  }
return *p.FVal
}
var Value_SVal_DEFAULT []byte

func (p *Value) GetSVal() []byte {
  return p.SVal
}
var Value_DVal_DEFAULT *Date
func (p *Value) GetDVal() *Date {
  if !p.IsSetDVal() {
    return Value_DVal_DEFAULT
  }
return p.DVal
}
var Value_TVal_DEFAULT *Time
func (p *Value) GetTVal() *Time {
  if !p.IsSetTVal() {
    return Value_TVal_DEFAULT
  }
return p.TVal
}
var Value_DtVal_DEFAULT *DateTime
func (p *Value) GetDtVal() *DateTime {
  if !p.IsSetDtVal() {
    return Value_DtVal_DEFAULT
  }
return p.DtVal
}
var Value_VVal_DEFAULT *Vertex
func (p *Value) GetVVal() *Vertex {
  if !p.IsSetVVal() {
    return Value_VVal_DEFAULT
  }
return p.VVal
}
var Value_EVal_DEFAULT *Edge
func (p *Value) GetEVal() *Edge {
  if !p.IsSetEVal() {
    return Value_EVal_DEFAULT
  }
return p.EVal
}
var Value_PVal_DEFAULT *Path
func (p *Value) GetPVal() *Path {
  if !p.IsSetPVal() {
    return Value_PVal_DEFAULT
  }
return p.PVal
}
var Value_LVal_DEFAULT *NList
func (p *Value) GetLVal() *NList {
  if !p.IsSetLVal() {
    return Value_LVal_DEFAULT
  }
return p.LVal
}
var Value_MVal_DEFAULT *NMap
func (p *Value) GetMVal() *NMap {
  if !p.IsSetMVal() {
    return Value_MVal_DEFAULT
  }
return p.MVal
}
var Value_UVal_DEFAULT *NSet
func (p *Value) GetUVal() *NSet {
  if !p.IsSetUVal() {
    return Value_UVal_DEFAULT
  }
return p.UVal
}
var Value_GVal_DEFAULT *DataSet
func (p *Value) GetGVal() *DataSet {
  if !p.IsSetGVal() {
    return Value_GVal_DEFAULT
  }
return p.GVal
}
var Value_GgVal_DEFAULT *Geography
func (p *Value) GetGgVal() *Geography {
  if !p.IsSetGgVal() {
    return Value_GgVal_DEFAULT
  }
return p.GgVal
}
var Value_DuVal_DEFAULT *Duration
func (p *Value) GetDuVal() *Duration {
  if !p.IsSetDuVal() {
    return Value_DuVal_DEFAULT
  }
return p.DuVal
}
func (p *Value) CountSetFieldsValue() int {
  count := 0
  if (p.IsSetNVal()) {
    count++
  }
  if (p.IsSetBVal()) {
    count++
  }
  if (p.IsSetIVal()) {
    count++
  }
  if (p.IsSetFVal()) {
    count++
  }
  if (p.IsSetSVal()) {
    count++
  }
  if (p.IsSetDVal()) {
    count++
  }
  if (p.IsSetTVal()) {
    count++
  }
  if (p.IsSetDtVal()) {
    count++
  }
  if (p.IsSetVVal()) {
    count++
  }
  if (p.IsSetEVal()) {
    count++
  }
  if (p.IsSetPVal()) {
    count++
  }
  if (p.IsSetLVal()) {
    count++
  }
  if (p.IsSetMVal()) {
    count++
  }
  if (p.IsSetUVal()) {
    count++
  }
  if (p.IsSetGVal()) {
    count++
  }
  if (p.IsSetGgVal()) {
    count++
  }
  if (p.IsSetDuVal()) {
    count++
  }
  return count

}

func (p *Value) IsSetNVal() bool {
  return p.NVal != nil
}

func (p *Value) IsSetBVal() bool {
  return p.BVal != nil
}

func (p *Value) IsSetIVal() bool {
  return p.IVal != nil
}

func (p *Value) IsSetFVal() bool {
  return p.FVal != nil
}

func (p *Value) IsSetSVal() bool {
  return p.SVal != nil
}

func (p *Value) IsSetDVal() bool {
  return p.DVal != nil
}

func (p *Value) IsSetTVal() bool {
  return p.TVal != nil
}

func (p *Value) IsSetDtVal() bool {
  return p.DtVal != nil
}

func (p *Value) IsSetVVal() bool {
  return p.VVal != nil
}

func (p *Value) IsSetEVal() bool {
  return p.EVal != nil
}

func (p *Value) IsSetPVal() bool {
  return p.PVal != nil
}

func (p *Value) IsSetLVal() bool {
  return p.LVal != nil
}

func (p *Value) IsSetMVal() bool {
  return p.MVal != nil
}

func (p *Value) IsSetUVal() bool {
  return p.UVal != nil
}

func (p *Value) IsSetGVal() bool {
  return p.GVal != nil
}

func (p *Value) IsSetGgVal() bool {
  return p.GgVal != nil
}

func (p *Value) IsSetDuVal() bool {
  return p.DuVal != nil
}

func (p *Value) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.DOUBLE {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 5:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField5(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 6:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField6(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 7:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField7(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 8:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField8(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 9:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField9(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 10:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField10(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 11:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField11(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 12:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField12(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 13:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField13(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 14:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField14(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 15:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField15(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 16:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField16(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 17:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField17(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *Value)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  temp := NullType(v)
  p.NVal = &temp
}
  return nil
}

func (p *Value)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.BVal = &v
}
  return nil
}

func (p *Value)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.IVal = &v
}
  return nil
}

func (p *Value)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadDouble(ctx); err != nil {
  return thrift.PrependError("error reading field 4: ", err)
} else {
  p.FVal = &v
}
  return nil
}

func (p *Value)  ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 5: ", err)
} else {
  p.SVal = v
}
  return nil
}

func (p *Value)  ReadField6(ctx context.Context, iprot thrift.TProtocol) error {
  p.DVal = &Date{}
  if err := p.DVal.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.DVal), err)
  }
  return nil
}

func (p *Value)  ReadField7(ctx context.Context, iprot thrift.TProtocol) error {
  p.TVal = &Time{}
  if err := p.TVal.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.TVal), err)
  }
  return nil
}

func (p *Value)  ReadField8(ctx context.Context, iprot thrift.TProtocol) error {
  p.DtVal = &DateTime{}
  if err := p.DtVal.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.DtVal), err)
  }
  return nil
}

func (p *Value)  ReadField9(ctx context.Context, iprot thrift.TProtocol) error {
  p.VVal = &Vertex{}
  if err := p.VVal.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.VVal), err)
  }
  return nil
}

func (p *Value)  ReadField10(ctx context.Context, iprot thrift.TProtocol) error {
  p.EVal = &Edge{}
  if err := p.EVal.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.EVal), err)
  }
  return nil
}

func (p *Value)  ReadField11(ctx context.Context, iprot thrift.TProtocol) error {
  p.PVal = &Path{}
  if err := p.PVal.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.PVal), err)
  }
  return nil
}

func (p *Value)  ReadField12(ctx context.Context, iprot thrift.TProtocol) error {
  p.LVal = &NList{}
  if err := p.LVal.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.LVal), err)
  }
  return nil
}

func (p *Value)  ReadField13(ctx context.Context, iprot thrift.TProtocol) error {
  p.MVal = &NMap{}
  if err := p.MVal.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.MVal), err)
  }
  return nil
}

func (p *Value)  ReadField14(ctx context.Context, iprot thrift.TProtocol) error {
  p.UVal = &NSet{}
  if err := p.UVal.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.UVal), err)
  }
  return nil
}

func (p *Value)  ReadField15(ctx context.Context, iprot thrift.TProtocol) error {
  p.GVal = &DataSet{}
  if err := p.GVal.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.GVal), err)
  }
  return nil
}

func (p *Value)  ReadField16(ctx context.Context, iprot thrift.TProtocol) error {
  p.GgVal = &Geography{}
  if err := p.GgVal.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.GgVal), err)
  }
  return nil
}

func (p *Value)  ReadField17(ctx context.Context, iprot thrift.TProtocol) error {
  p.DuVal = &Duration{}
  if err := p.DuVal.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.DuVal), err)
  }
  return nil
}

func (p *Value) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if c := p.CountSetFieldsValue(); c != 1 {
    return fmt.Errorf("%T write union: exactly one field must be set (%d set)", p, c)
  }
  if err := oprot.WriteStructBegin(ctx, "Value"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
    if err := p.writeField5(ctx, oprot); err != nil { return err }
    if err := p.writeField6(ctx, oprot); err != nil { return err }
    if err := p.writeField7(ctx, oprot); err != nil { return err }
    if err := p.writeField8(ctx, oprot); err != nil { return err }
    if err := p.writeField9(ctx, oprot); err != nil { return err }
    if err := p.writeField10(ctx, oprot); err != nil { return err }
    if err := p.writeField11(ctx, oprot); err != nil { return err }
    if err := p.writeField12(ctx, oprot); err != nil { return err }
    if err := p.writeField13(ctx, oprot); err != nil { return err }
    if err := p.writeField14(ctx, oprot); err != nil { return err }
    if err := p.writeField15(ctx, oprot); err != nil { return err }
    if err := p.writeField16(ctx, oprot); err != nil { return err }
    if err := p.writeField17(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *Value) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetNVal() {
    if err := oprot.WriteFieldBegin(ctx, "nVal", thrift.I32, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:nVal: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.NVal)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.nVal (1) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:nVal: ", p), err) }
  }
  return err
}

func (p *Value) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetBVal() {
    if err := oprot.WriteFieldBegin(ctx, "bVal", thrift.BOOL, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:bVal: ", p), err) }
    if err := oprot.WriteBool(ctx, bool(*p.BVal)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.bVal (2) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:bVal: ", p), err) }
  }
  return err
}

func (p *Value) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetIVal() {
    if err := oprot.WriteFieldBegin(ctx, "iVal", thrift.I64, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:iVal: ", p), err) }
    if err := oprot.WriteI64(ctx, int64(*p.IVal)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.iVal (3) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:iVal: ", p), err) }
  }
  return err
}

func (p *Value) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetFVal() {
    if err := oprot.WriteFieldBegin(ctx, "fVal", thrift.DOUBLE, 4); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:fVal: ", p), err) }
    if err := oprot.WriteDouble(ctx, float64(*p.FVal)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.fVal (4) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 4:fVal: ", p), err) }
  }
  return err
}

func (p *Value) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSVal() {
    if err := oprot.WriteFieldBegin(ctx, "sVal", thrift.STRING, 5); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:sVal: ", p), err) }
    if err := oprot.WriteBinary(ctx, p.SVal); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.sVal (5) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 5:sVal: ", p), err) }
  }
  return err
}

func (p *Value) writeField6(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetDVal() {
    if err := oprot.WriteFieldBegin(ctx, "dVal", thrift.STRUCT, 6); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 6:dVal: ", p), err) }
    if err := p.DVal.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.DVal), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 6:dVal: ", p), err) }
  }
  return err
}

func (p *Value) writeField7(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetTVal() {
    if err := oprot.WriteFieldBegin(ctx, "tVal", thrift.STRUCT, 7); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 7:tVal: ", p), err) }
    if err := p.TVal.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.TVal), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 7:tVal: ", p), err) }
  }
  return err
}

func (p *Value) writeField8(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetDtVal() {
    if err := oprot.WriteFieldBegin(ctx, "dtVal", thrift.STRUCT, 8); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 8:dtVal: ", p), err) }
    if err := p.DtVal.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.DtVal), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 8:dtVal: ", p), err) }
  }
  return err
}

func (p *Value) writeField9(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetVVal() {
    if err := oprot.WriteFieldBegin(ctx, "vVal", thrift.STRUCT, 9); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 9:vVal: ", p), err) }
    if err := p.VVal.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.VVal), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 9:vVal: ", p), err) }
  }
  return err
}

func (p *Value) writeField10(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetEVal() {
    if err := oprot.WriteFieldBegin(ctx, "eVal", thrift.STRUCT, 10); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 10:eVal: ", p), err) }
    if err := p.EVal.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.EVal), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 10:eVal: ", p), err) }
  }
  return err
}

func (p *Value) writeField11(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetPVal() {
    if err := oprot.WriteFieldBegin(ctx, "pVal", thrift.STRUCT, 11); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 11:pVal: ", p), err) }
    if err := p.PVal.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.PVal), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 11:pVal: ", p), err) }
  }
  return err
}

func (p *Value) writeField12(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetLVal() {
    if err := oprot.WriteFieldBegin(ctx, "lVal", thrift.STRUCT, 12); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 12:lVal: ", p), err) }
    if err := p.LVal.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.LVal), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 12:lVal: ", p), err) }
  }
  return err
}

func (p *Value) writeField13(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetMVal() {
    if err := oprot.WriteFieldBegin(ctx, "mVal", thrift.STRUCT, 13); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 13:mVal: ", p), err) }
    if err := p.MVal.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.MVal), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 13:mVal: ", p), err) }
  }
  return err
}

func (p *Value) writeField14(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetUVal() {
    if err := oprot.WriteFieldBegin(ctx, "uVal", thrift.STRUCT, 14); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 14:uVal: ", p), err) }
    if err := p.UVal.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.UVal), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 14:uVal: ", p), err) }
  }
  return err
}

func (p *Value) writeField15(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetGVal() {
    if err := oprot.WriteFieldBegin(ctx, "gVal", thrift.STRUCT, 15); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 15:gVal: ", p), err) }
    if err := p.GVal.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.GVal), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 15:gVal: ", p), err) }
  }
  return err
}

func (p *Value) writeField16(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetGgVal() {
    if err := oprot.WriteFieldBegin(ctx, "ggVal", thrift.STRUCT, 16); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 16:ggVal: ", p), err) }
    if err := p.GgVal.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.GgVal), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 16:ggVal: ", p), err) }
  }
  return err
}

func (p *Value) writeField17(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetDuVal() {
    if err := oprot.WriteFieldBegin(ctx, "duVal", thrift.STRUCT, 17); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 17:duVal: ", p), err) }
    if err := p.DuVal.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.DuVal), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 17:duVal: ", p), err) }
  }
  return err
}

func (p *Value) Equals(other *Value) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.NVal != other.NVal {
    if p.NVal == nil || other.NVal == nil {
      return false
    }
    if (*p.NVal) != (*other.NVal) { return false }
  }
  if p.BVal != other.BVal {
    if p.BVal == nil || other.BVal == nil {
      return false
    }
    if (*p.BVal) != (*other.BVal) { return false }
  }
  if p.IVal != other.IVal {
    if p.IVal == nil || other.IVal == nil {
      return false
    }
    if (*p.IVal) != (*other.IVal) { return false }
  }
  if p.FVal != other.FVal {
    if p.FVal == nil || other.FVal == nil {
      return false
    }
    if (*p.FVal) != (*other.FVal) { return false }
  }
  if bytes.Compare(p.SVal, other.SVal) != 0 { return false }
  if !p.DVal.Equals(other.DVal) { return false }
  if !p.TVal.Equals(other.TVal) { return false }
  if !p.DtVal.Equals(other.DtVal) { return false }
  if !p.VVal.Equals(other.VVal) { return false }
  if !p.EVal.Equals(other.EVal) { return false }
  if !p.PVal.Equals(other.PVal) { return false }
  if !p.LVal.Equals(other.LVal) { return false }
  if !p.MVal.Equals(other.MVal) { return false }
  if !p.UVal.Equals(other.UVal) { return false }
  if !p.GVal.Equals(other.GVal) { return false }
  if !p.GgVal.Equals(other.GgVal) { return false }
  if !p.DuVal.Equals(other.DuVal) { return false }
  return true
}

func (p *Value) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("Value(%+v)", *p)
}

func (p *Value) Validate() error {
  return nil
}
// Attributes:
//  - Values
type NList struct {
  Values []*Value `thrift:"values,1" db:"values" json:"values"`
}

func NewNList() *NList {
  return &NList{}
}


func (p *NList) GetValues() []*Value {
  return p.Values
}
func (p *NList) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NList)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]*Value, 0, size)
  p.Values =  tSlice
  for i := 0; i < size; i ++ {
    _elem0 := &Value{}
    if err := _elem0.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem0), err)
    }
    p.Values = append(p.Values, _elem0)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *NList) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "NList"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NList) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "values", thrift.LIST, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:values: ", p), err) }
  if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.Values)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
  }
  for _, v := range p.Values {
    if err := v.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
    }
  }
  if err := oprot.WriteListEnd(ctx); err != nil {
    return thrift.PrependError("error writing list end: ", err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:values: ", p), err) }
  return err
}

func (p *NList) Equals(other *NList) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if len(p.Values) != len(other.Values) { return false }
  for i, _tgt := range p.Values {
    _src1 := other.Values[i]
    if !_tgt.Equals(_src1) { return false }
  }
  return true
}

func (p *NList) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NList(%+v)", *p)
}

func (p *NList) Validate() error {
  return nil
}
// Attributes:
//  - Kvs
type NMap struct {
  Kvs map[string]*Value `thrift:"kvs,1" db:"kvs" json:"kvs"`
}

func NewNMap() *NMap {
  return &NMap{}
}


func (p *NMap) GetKvs() map[string]*Value {
  return p.Kvs
}
func (p *NMap) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.MAP {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NMap)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  _, _, size, err := iprot.ReadMapBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading map begin: ", err)
  }
  tMap := make(map[string]*Value, size)
  p.Kvs =  tMap
  for i := 0; i < size; i ++ {
var _key2 string
    if v, err := iprot.ReadString(ctx); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    _key2 = v
}
    _val3 := &Value{}
    if err := _val3.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _val3), err)
    }
    p.Kvs[_key2] = _val3
  }
  if err := iprot.ReadMapEnd(ctx); err != nil {
    return thrift.PrependError("error reading map end: ", err)
  }
  return nil
}

func (p *NMap) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "NMap"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NMap) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "kvs", thrift.MAP, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:kvs: ", p), err) }
  if err := oprot.WriteMapBegin(ctx, thrift.STRING, thrift.STRUCT, len(p.Kvs)); err != nil {
    return thrift.PrependError("error writing map begin: ", err)
  }
  for k, v := range p.Kvs {
    if err := oprot.WriteString(ctx, string(k)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
    if err := v.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
    }
  }
  if err := oprot.WriteMapEnd(ctx); err != nil {
    return thrift.PrependError("error writing map end: ", err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:kvs: ", p), err) }
  return err
}

func (p *NMap) Equals(other *NMap) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if len(p.Kvs) != len(other.Kvs) { return false }
  for k, _tgt := range p.Kvs {
    _src4 := other.Kvs[k]
    if !_tgt.Equals(_src4) { return false }
  }
  return true
}

func (p *NMap) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NMap(%+v)", *p)
}

func (p *NMap) Validate() error {
  return nil
}
// Attributes:
//  - Values
type NSet struct {
  Values []*Value `thrift:"values,1" db:"values" json:"values"`
}

func NewNSet() *NSet {
  return &NSet{}
}


func (p *NSet) GetValues() []*Value {
  return p.Values
}
func (p *NSet) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.SET {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NSet)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadSetBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading set begin: ", err)
  }
  tSet := make([]*Value, 0, size)
  p.Values =  tSet
  for i := 0; i < size; i ++ {
    _elem5 := &Value{}
    if err := _elem5.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem5), err)
    }
    p.Values = append(p.Values, _elem5)
  }
  if err := iprot.ReadSetEnd(ctx); err != nil {
    return thrift.PrependError("error reading set end: ", err)
  }
  return nil
}

func (p *NSet) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "NSet"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NSet) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "values", thrift.SET, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:values: ", p), err) }
  if err := oprot.WriteSetBegin(ctx, thrift.STRUCT, len(p.Values)); err != nil {
    return thrift.PrependError("error writing set begin: ", err)
  }
  for i := 0; i<len(p.Values); i++ {
    for j := i+1; j<len(p.Values); j++ {
      if func(tgt, src *Value) bool {
        if !tgt.Equals(src) { return false }
        return true
      }(p.Values[i], p.Values[j]) {
        return thrift.PrependError("", fmt.Errorf("%T error writing set field: slice is not unique", p.Values))
      }
    }
  }
  for _, v := range p.Values {
    if err := v.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
    }
  }
  if err := oprot.WriteSetEnd(ctx); err != nil {
    return thrift.PrependError("error writing set end: ", err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:values: ", p), err) }
  return err
}

func (p *NSet) Equals(other *NSet) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if len(p.Values) != len(other.Values) { return false }
  for i, _tgt := range p.Values {
    _src6 := other.Values[i]
    if !_tgt.Equals(_src6) { return false }
  }
  return true
}

func (p *NSet) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NSet(%+v)", *p)
}

func (p *NSet) Validate() error {
  return nil
}
// Attributes:
//  - Values
type Row struct {
  Values []*Value `thrift:"values,1" db:"values" json:"values"`
}

func NewRow() *Row {
  return &Row{}
}


func (p *Row) GetValues() []*Value {
  return p.Values
}
func (p *Row) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *Row)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]*Value, 0, size)
  p.Values =  tSlice
  for i := 0; i < size; i ++ {
    _elem7 := &Value{}
    if err := _elem7.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem7), err)
    }
    p.Values = append(p.Values, _elem7)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *Row) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "Row"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *Row) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "values", thrift.LIST, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:values: ", p), err) }
  if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.Values)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
  }
  for _, v := range p.Values {
    if err := v.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
    }
  }
  if err := oprot.WriteListEnd(ctx); err != nil {
    return thrift.PrependError("error writing list end: ", err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:values: ", p), err) }
  return err
}

func (p *Row) Equals(other *Row) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if len(p.Values) != len(other.Values) { return false }
  for i, _tgt := range p.Values {
    _src8 := other.Values[i]
    if !_tgt.Equals(_src8) { return false }
  }
  return true
}

func (p *Row) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("Row(%+v)", *p)
}

func (p *Row) Validate() error {
  return nil
}
// Attributes:
//  - ColumnNames
//  - Rows
type DataSet struct {
  ColumnNames [][]byte `thrift:"column_names,1" db:"column_names" json:"column_names"`
  Rows []*Row `thrift:"rows,2" db:"rows" json:"rows"`
}

func NewDataSet() *DataSet {
  return &DataSet{}
}


func (p *DataSet) GetColumnNames() [][]byte {
  return p.ColumnNames
}

func (p *DataSet) GetRows() []*Row {
  return p.Rows
}
func (p *DataSet) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *DataSet)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([][]byte, 0, size)
  p.ColumnNames =  tSlice
  for i := 0; i < size; i ++ {
var _elem9 []byte
    if v, err := iprot.ReadBinary(ctx); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    _elem9 = v
}
    p.ColumnNames = append(p.ColumnNames, _elem9)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *DataSet)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]*Row, 0, size)
  p.Rows =  tSlice
  for i := 0; i < size; i ++ {
    _elem10 := &Row{}
    if err := _elem10.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem10), err)
    }
    p.Rows = append(p.Rows, _elem10)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *DataSet) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "DataSet"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *DataSet) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "column_names", thrift.LIST, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:column_names: ", p), err) }
  if err := oprot.WriteListBegin(ctx, thrift.STRING, len(p.ColumnNames)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
  }
  for _, v := range p.ColumnNames {
    if err := oprot.WriteBinary(ctx, v); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
  }
  if err := oprot.WriteListEnd(ctx); err != nil {
    return thrift.PrependError("error writing list end: ", err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:column_names: ", p), err) }
  return err
}

func (p *DataSet) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "rows", thrift.LIST, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:rows: ", p), err) }
  if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.Rows)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
  }
  for _, v := range p.Rows {
    if err := v.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
    }
  }
  if err := oprot.WriteListEnd(ctx); err != nil {
    return thrift.PrependError("error writing list end: ", err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:rows: ", p), err) }
  return err
}

func (p *DataSet) Equals(other *DataSet) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if len(p.ColumnNames) != len(other.ColumnNames) { return false }
  for i, _tgt := range p.ColumnNames {
    _src11 := other.ColumnNames[i]
    if bytes.Compare(_tgt, _src11) != 0 { return false }
  }
  if len(p.Rows) != len(other.Rows) { return false }
  for i, _tgt := range p.Rows {
    _src12 := other.Rows[i]
    if !_tgt.Equals(_src12) { return false }
  }
  return true
}

func (p *DataSet) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("DataSet(%+v)", *p)
}

func (p *DataSet) Validate() error {
  return nil
}
// Attributes:
//  - X
//  - Y
type Coordinate struct {
  X float64 `thrift:"x,1" db:"x" json:"x"`
  Y float64 `thrift:"y,2" db:"y" json:"y"`
}

func NewCoordinate() *Coordinate {
  return &Coordinate{}
}


func (p *Coordinate) GetX() float64 {
  return p.X
}

func (p *Coordinate) GetY() float64 {
  return p.Y
}
func (p *Coordinate) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.DOUBLE {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.DOUBLE {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *Coordinate)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadDouble(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.X = v
}
  return nil
}

func (p *Coordinate)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadDouble(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.Y = v
}
  return nil
}

func (p *Coordinate) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "Coordinate"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *Coordinate) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "x", thrift.DOUBLE, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:x: ", p), err) }
  if err := oprot.WriteDouble(ctx, float64(p.X)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.x (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:x: ", p), err) }
  return err
}

func (p *Coordinate) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "y", thrift.DOUBLE, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:y: ", p), err) }
  if err := oprot.WriteDouble(ctx, float64(p.Y)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.y (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:y: ", p), err) }
  return err
}

func (p *Coordinate) Equals(other *Coordinate) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.X != other.X { return false }
  if p.Y != other.Y { return false }
  return true
}

func (p *Coordinate) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("Coordinate(%+v)", *p)
}

func (p *Coordinate) Validate() error {
  return nil
}
// Attributes:
//  - Coord
type Point struct {
  Coord *Coordinate `thrift:"coord,1" db:"coord" json:"coord"`
}

func NewPoint() *Point {
  return &Point{}
}

var Point_Coord_DEFAULT *Coordinate
func (p *Point) GetCoord() *Coordinate {
  if !p.IsSetCoord() {
    return Point_Coord_DEFAULT
  }
return p.Coord
}
func (p *Point) IsSetCoord() bool {
  return p.Coord != nil
}

func (p *Point) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *Point)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Coord = &Coordinate{}
  if err := p.Coord.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Coord), err)
  }
  return nil
}

func (p *Point) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "Point"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *Point) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "coord", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:coord: ", p), err) }
  if err := p.Coord.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Coord), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:coord: ", p), err) }
  return err
}

func (p *Point) Equals(other *Point) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if !p.Coord.Equals(other.Coord) { return false }
  return true
}

func (p *Point) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("Point(%+v)", *p)
}

func (p *Point) Validate() error {
  return nil
}
// Attributes:
//  - CoordList
type LineString struct {
  CoordList []*Coordinate `thrift:"coordList,1" db:"coordList" json:"coordList"`
}

func NewLineString() *LineString {
  return &LineString{}
}


func (p *LineString) GetCoordList() []*Coordinate {
  return p.CoordList
}
func (p *LineString) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *LineString)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]*Coordinate, 0, size)
  p.CoordList =  tSlice
  for i := 0; i < size; i ++ {
    _elem13 := &Coordinate{}
    if err := _elem13.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem13), err)
    }
    p.CoordList = append(p.CoordList, _elem13)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *LineString) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "LineString"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *LineString) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "coordList", thrift.LIST, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:coordList: ", p), err) }
  if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.CoordList)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
  }
  for _, v := range p.CoordList {
    if err := v.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
    }
  }
  if err := oprot.WriteListEnd(ctx); err != nil {
    return thrift.PrependError("error writing list end: ", err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:coordList: ", p), err) }
  return err
}

func (p *LineString) Equals(other *LineString) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if len(p.CoordList) != len(other.CoordList) { return false }
  for i, _tgt := range p.CoordList {
    _src14 := other.CoordList[i]
    if !_tgt.Equals(_src14) { return false }
  }
  return true
}

func (p *LineString) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("LineString(%+v)", *p)
}

func (p *LineString) Validate() error {
  return nil
}
// Attributes:
//  - CoordListList
type Polygon struct {
  CoordListList [][]*Coordinate `thrift:"coordListList,1" db:"coordListList" json:"coordListList"`
}

func NewPolygon() *Polygon {
  return &Polygon{}
}


func (p *Polygon) GetCoordListList() [][]*Coordinate {
  return p.CoordListList
}
func (p *Polygon) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *Polygon)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([][]*Coordinate, 0, size)
  p.CoordListList =  tSlice
  for i := 0; i < size; i ++ {
    _, size, err := iprot.ReadListBegin(ctx)
    if err != nil {
      return thrift.PrependError("error reading list begin: ", err)
    }
    tSlice := make([]*Coordinate, 0, size)
    _elem15 :=  tSlice
    for i := 0; i < size; i ++ {
      _elem16 := &Coordinate{}
      if err := _elem16.Read(ctx, iprot); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem16), err)
      }
      _elem15 = append(_elem15, _elem16)
    }
    if err := iprot.ReadListEnd(ctx); err != nil {
      return thrift.PrependError("error reading list end: ", err)
    }
    p.CoordListList = append(p.CoordListList, _elem15)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *Polygon) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "Polygon"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *Polygon) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "coordListList", thrift.LIST, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:coordListList: ", p), err) }
  if err := oprot.WriteListBegin(ctx, thrift.LIST, len(p.CoordListList)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
  }
  for _, v := range p.CoordListList {
    if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(v)); err != nil {
      return thrift.PrependError("error writing list begin: ", err)
    }
    for _, v := range v {
      if err := v.Write(ctx, oprot); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
      }
    }
    if err := oprot.WriteListEnd(ctx); err != nil {
      return thrift.PrependError("error writing list end: ", err)
    }
  }
  if err := oprot.WriteListEnd(ctx); err != nil {
    return thrift.PrependError("error writing list end: ", err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:coordListList: ", p), err) }
  return err
}

func (p *Polygon) Equals(other *Polygon) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if len(p.CoordListList) != len(other.CoordListList) { return false }
  for i, _tgt := range p.CoordListList {
    _src17 := other.CoordListList[i]
    if len(_tgt) != len(_src17) { return false }
    for i, _tgt := range _tgt {
      _src18 := _src17[i]
      if !_tgt.Equals(_src18) { return false }
    }
  }
  return true
}

func (p *Polygon) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("Polygon(%+v)", *p)
}

func (p *Polygon) Validate() error {
  return nil
}
// Attributes:
//  - PtVal
//  - LsVal
//  - PgVal
type Geography struct {
  PtVal *Point `thrift:"ptVal,1" db:"ptVal" json:"ptVal,omitempty"`
  LsVal *LineString `thrift:"lsVal,2" db:"lsVal" json:"lsVal,omitempty"`
  PgVal *Polygon `thrift:"pgVal,3" db:"pgVal" json:"pgVal,omitempty"`
}

func NewGeography() *Geography {
  return &Geography{}
}

var Geography_PtVal_DEFAULT *Point
func (p *Geography) GetPtVal() *Point {
  if !p.IsSetPtVal() {
    return Geography_PtVal_DEFAULT
  }
return p.PtVal
}
var Geography_LsVal_DEFAULT *LineString
func (p *Geography) GetLsVal() *LineString {
  if !p.IsSetLsVal() {
    return Geography_LsVal_DEFAULT
  }
return p.LsVal
}
var Geography_PgVal_DEFAULT *Polygon
func (p *Geography) GetPgVal() *Polygon {
  if !p.IsSetPgVal() {
    return Geography_PgVal_DEFAULT
  }
return p.PgVal
}
func (p *Geography) CountSetFieldsGeography() int {
  count := 0
  if (p.IsSetPtVal()) {
    count++
  }
  if (p.IsSetLsVal()) {
    count++
  }
  if (p.IsSetPgVal()) {
    count++
  }
  return count

}

func (p *Geography) IsSetPtVal() bool {
  return p.PtVal != nil
}

func (p *Geography) IsSetLsVal() bool {
  return p.LsVal != nil
}

func (p *Geography) IsSetPgVal() bool {
  return p.PgVal != nil
}

func (p *Geography) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *Geography)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.PtVal = &Point{}
  if err := p.PtVal.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.PtVal), err)
  }
  return nil
}

func (p *Geography)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.LsVal = &LineString{}
  if err := p.LsVal.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.LsVal), err)
  }
  return nil
}

func (p *Geography)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.PgVal = &Polygon{}
  if err := p.PgVal.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.PgVal), err)
  }
  return nil
}

func (p *Geography) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if c := p.CountSetFieldsGeography(); c != 1 {
    return fmt.Errorf("%T write union: exactly one field must be set (%d set)", p, c)
  }
  if err := oprot.WriteStructBegin(ctx, "Geography"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *Geography) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetPtVal() {
    if err := oprot.WriteFieldBegin(ctx, "ptVal", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ptVal: ", p), err) }
    if err := p.PtVal.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.PtVal), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ptVal: ", p), err) }
  }
  return err
}

func (p *Geography) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetLsVal() {
    if err := oprot.WriteFieldBegin(ctx, "lsVal", thrift.STRUCT, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:lsVal: ", p), err) }
    if err := p.LsVal.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.LsVal), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:lsVal: ", p), err) }
  }
  return err
}

func (p *Geography) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetPgVal() {
    if err := oprot.WriteFieldBegin(ctx, "pgVal", thrift.STRUCT, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:pgVal: ", p), err) }
    if err := p.PgVal.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.PgVal), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:pgVal: ", p), err) }
  }
  return err
}

func (p *Geography) Equals(other *Geography) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if !p.PtVal.Equals(other.PtVal) { return false }
  if !p.LsVal.Equals(other.LsVal) { return false }
  if !p.PgVal.Equals(other.PgVal) { return false }
  return true
}

func (p *Geography) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("Geography(%+v)", *p)
}

func (p *Geography) Validate() error {
  return nil
}
// Attributes:
//  - Name
//  - Props
type Tag struct {
  Name []byte `thrift:"name,1" db:"name" json:"name"`
  Props map[string]*Value `thrift:"props,2" db:"props" json:"props"`
}

func NewTag() *Tag {
  return &Tag{}
}


func (p *Tag) GetName() []byte {
  return p.Name
}

func (p *Tag) GetProps() map[string]*Value {
  return p.Props
}
func (p *Tag) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.MAP {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *Tag)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Name = v
}
  return nil
}

func (p *Tag)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  _, _, size, err := iprot.ReadMapBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading map begin: ", err)
  }
  tMap := make(map[string]*Value, size)
  p.Props =  tMap
  for i := 0; i < size; i ++ {
var _key19 string
    if v, err := iprot.ReadString(ctx); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    _key19 = v
}
    _val20 := &Value{}
    if err := _val20.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _val20), err)
    }
    p.Props[_key19] = _val20
  }
  if err := iprot.ReadMapEnd(ctx); err != nil {
    return thrift.PrependError("error reading map end: ", err)
  }
  return nil
}

func (p *Tag) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "Tag"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *Tag) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "name", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:name: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Name); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.name (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:name: ", p), err) }
  return err
}

func (p *Tag) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "props", thrift.MAP, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:props: ", p), err) }
  if err := oprot.WriteMapBegin(ctx, thrift.STRING, thrift.STRUCT, len(p.Props)); err != nil {
    return thrift.PrependError("error writing map begin: ", err)
  }
  for k, v := range p.Props {
    if err := oprot.WriteString(ctx, string(k)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
    if err := v.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
    }
  }
  if err := oprot.WriteMapEnd(ctx); err != nil {
    return thrift.PrependError("error writing map end: ", err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:props: ", p), err) }
  return err
}

func (p *Tag) Equals(other *Tag) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if bytes.Compare(p.Name, other.Name) != 0 { return false }
  if len(p.Props) != len(other.Props) { return false }
  for k, _tgt := range p.Props {
    _src21 := other.Props[k]
    if !_tgt.Equals(_src21) { return false }
  }
  return true
}

func (p *Tag) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("Tag(%+v)", *p)
}

func (p *Tag) Validate() error {
  return nil
}
// Attributes:
//  - Vid
//  - Tags
type Vertex struct {
  Vid *Value `thrift:"vid,1" db:"vid" json:"vid"`
  Tags []*Tag `thrift:"tags,2" db:"tags" json:"tags"`
}

func NewVertex() *Vertex {
  return &Vertex{}
}

var Vertex_Vid_DEFAULT *Value
func (p *Vertex) GetVid() *Value {
  if !p.IsSetVid() {
    return Vertex_Vid_DEFAULT
  }
return p.Vid
}

func (p *Vertex) GetTags() []*Tag {
  return p.Tags
}
func (p *Vertex) IsSetVid() bool {
  return p.Vid != nil
}

func (p *Vertex) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *Vertex)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Vid = &Value{}
  if err := p.Vid.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Vid), err)
  }
  return nil
}

func (p *Vertex)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]*Tag, 0, size)
  p.Tags =  tSlice
  for i := 0; i < size; i ++ {
    _elem22 := &Tag{}
    if err := _elem22.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem22), err)
    }
    p.Tags = append(p.Tags, _elem22)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *Vertex) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "Vertex"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *Vertex) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "vid", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:vid: ", p), err) }
  if err := p.Vid.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Vid), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:vid: ", p), err) }
  return err
}

func (p *Vertex) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "tags", thrift.LIST, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:tags: ", p), err) }
  if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.Tags)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
  }
  for _, v := range p.Tags {
    if err := v.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
    }
  }
  if err := oprot.WriteListEnd(ctx); err != nil {
    return thrift.PrependError("error writing list end: ", err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:tags: ", p), err) }
  return err
}

func (p *Vertex) Equals(other *Vertex) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if !p.Vid.Equals(other.Vid) { return false }
  if len(p.Tags) != len(other.Tags) { return false }
  for i, _tgt := range p.Tags {
    _src23 := other.Tags[i]
    if !_tgt.Equals(_src23) { return false }
  }
  return true
}

func (p *Vertex) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("Vertex(%+v)", *p)
}

func (p *Vertex) Validate() error {
  return nil
}
// Attributes:
//  - Src
//  - Dst
//  - Type
//  - Name
//  - Ranking
//  - Props
type Edge struct {
  Src *Value `thrift:"src,1" db:"src" json:"src"`
  Dst *Value `thrift:"dst,2" db:"dst" json:"dst"`
  Type EdgeType `thrift:"type,3" db:"type" json:"type"`
  Name []byte `thrift:"name,4" db:"name" json:"name"`
  Ranking EdgeRanking `thrift:"ranking,5" db:"ranking" json:"ranking"`
  Props map[string]*Value `thrift:"props,6" db:"props" json:"props"`
}

func NewEdge() *Edge {
  return &Edge{}
}

var Edge_Src_DEFAULT *Value
func (p *Edge) GetSrc() *Value {
  if !p.IsSetSrc() {
    return Edge_Src_DEFAULT
  }
return p.Src
}
var Edge_Dst_DEFAULT *Value
func (p *Edge) GetDst() *Value {
  if !p.IsSetDst() {
    return Edge_Dst_DEFAULT
  }
return p.Dst
}

func (p *Edge) GetType() EdgeType {
  return p.Type
}

func (p *Edge) GetName() []byte {
  return p.Name
}

func (p *Edge) GetRanking() EdgeRanking {
  return p.Ranking
}

func (p *Edge) GetProps() map[string]*Value {
  return p.Props
}
func (p *Edge) IsSetSrc() bool {
  return p.Src != nil
}

func (p *Edge) IsSetDst() bool {
  return p.Dst != nil
}

func (p *Edge) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 5:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField5(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 6:
      if fieldTypeId == thrift.MAP {
        if err := p.ReadField6(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *Edge)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Src = &Value{}
  if err := p.Src.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Src), err)
  }
  return nil
}

func (p *Edge)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Dst = &Value{}
  if err := p.Dst.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Dst), err)
  }
  return nil
}

func (p *Edge)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  temp := EdgeType(v)
  p.Type = temp
}
  return nil
}

func (p *Edge)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 4: ", err)
} else {
  p.Name = v
}
  return nil
}

func (p *Edge)  ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 5: ", err)
} else {
  temp := EdgeRanking(v)
  p.Ranking = temp
}
  return nil
}

func (p *Edge)  ReadField6(ctx context.Context, iprot thrift.TProtocol) error {
  _, _, size, err := iprot.ReadMapBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading map begin: ", err)
  }
  tMap := make(map[string]*Value, size)
  p.Props =  tMap
  for i := 0; i < size; i ++ {
var _key24 string
    if v, err := iprot.ReadString(ctx); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    _key24 = v
}
    _val25 := &Value{}
    if err := _val25.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _val25), err)
    }
    p.Props[_key24] = _val25
  }
  if err := iprot.ReadMapEnd(ctx); err != nil {
    return thrift.PrependError("error reading map end: ", err)
  }
  return nil
}

func (p *Edge) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "Edge"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
    if err := p.writeField5(ctx, oprot); err != nil { return err }
    if err := p.writeField6(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *Edge) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "src", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:src: ", p), err) }
  if err := p.Src.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Src), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:src: ", p), err) }
  return err
}

func (p *Edge) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "dst", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:dst: ", p), err) }
  if err := p.Dst.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Dst), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:dst: ", p), err) }
  return err
}

func (p *Edge) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "type", thrift.I32, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:type: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.Type)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.type (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:type: ", p), err) }
  return err
}

func (p *Edge) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "name", thrift.STRING, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:name: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Name); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.name (4) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:name: ", p), err) }
  return err
}

func (p *Edge) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "ranking", thrift.I64, 5); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:ranking: ", p), err) }
  if err := oprot.WriteI64(ctx, int64(p.Ranking)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.ranking (5) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 5:ranking: ", p), err) }
  return err
}

func (p *Edge) writeField6(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "props", thrift.MAP, 6); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 6:props: ", p), err) }
  if err := oprot.WriteMapBegin(ctx, thrift.STRING, thrift.STRUCT, len(p.Props)); err != nil {
    return thrift.PrependError("error writing map begin: ", err)
  }
  for k, v := range p.Props {
    if err := oprot.WriteString(ctx, string(k)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
    if err := v.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
    }
  }
  if err := oprot.WriteMapEnd(ctx); err != nil {
    return thrift.PrependError("error writing map end: ", err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 6:props: ", p), err) }
  return err
}

func (p *Edge) Equals(other *Edge) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if !p.Src.Equals(other.Src) { return false }
  if !p.Dst.Equals(other.Dst) { return false }
  if p.Type != other.Type { return false }
  if bytes.Compare(p.Name, other.Name) != 0 { return false }
  if p.Ranking != other.Ranking { return false }
  if len(p.Props) != len(other.Props) { return false }
  for k, _tgt := range p.Props {
    _src26 := other.Props[k]
    if !_tgt.Equals(_src26) { return false }
  }
  return true
}

func (p *Edge) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("Edge(%+v)", *p)
}

func (p *Edge) Validate() error {
  return nil
}
// Attributes:
//  - Dst
//  - Type
//  - Name
//  - Ranking
//  - Props
type Step struct {
  Dst *Vertex `thrift:"dst,1" db:"dst" json:"dst"`
  Type EdgeType `thrift:"type,2" db:"type" json:"type"`
  Name []byte `thrift:"name,3" db:"name" json:"name"`
  Ranking EdgeRanking `thrift:"ranking,4" db:"ranking" json:"ranking"`
  Props map[string]*Value `thrift:"props,5" db:"props" json:"props"`
}

func NewStep() *Step {
  return &Step{}
}

var Step_Dst_DEFAULT *Vertex
func (p *Step) GetDst() *Vertex {
  if !p.IsSetDst() {
    return Step_Dst_DEFAULT
  }
return p.Dst
}

func (p *Step) GetType() EdgeType {
  return p.Type
}

func (p *Step) GetName() []byte {
  return p.Name
}

func (p *Step) GetRanking() EdgeRanking {
  return p.Ranking
}

func (p *Step) GetProps() map[string]*Value {
  return p.Props
}
func (p *Step) IsSetDst() bool {
  return p.Dst != nil
}

func (p *Step) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 5:
      if fieldTypeId == thrift.MAP {
        if err := p.ReadField5(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *Step)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Dst = &Vertex{}
  if err := p.Dst.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Dst), err)
  }
  return nil
}

func (p *Step)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  temp := EdgeType(v)
  p.Type = temp
}
  return nil
}

func (p *Step)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.Name = v
}
  return nil
}

func (p *Step)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 4: ", err)
} else {
  temp := EdgeRanking(v)
  p.Ranking = temp
}
  return nil
}

func (p *Step)  ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
  _, _, size, err := iprot.ReadMapBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading map begin: ", err)
  }
  tMap := make(map[string]*Value, size)
  p.Props =  tMap
  for i := 0; i < size; i ++ {
var _key27 string
    if v, err := iprot.ReadString(ctx); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    _key27 = v
}
    _val28 := &Value{}
    if err := _val28.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _val28), err)
    }
    p.Props[_key27] = _val28
  }
  if err := iprot.ReadMapEnd(ctx); err != nil {
    return thrift.PrependError("error reading map end: ", err)
  }
  return nil
}

func (p *Step) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "Step"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
    if err := p.writeField5(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *Step) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "dst", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:dst: ", p), err) }
  if err := p.Dst.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Dst), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:dst: ", p), err) }
  return err
}

func (p *Step) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "type", thrift.I32, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:type: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.Type)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.type (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:type: ", p), err) }
  return err
}

func (p *Step) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "name", thrift.STRING, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:name: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Name); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.name (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:name: ", p), err) }
  return err
}

func (p *Step) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "ranking", thrift.I64, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:ranking: ", p), err) }
  if err := oprot.WriteI64(ctx, int64(p.Ranking)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.ranking (4) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:ranking: ", p), err) }
  return err
}

func (p *Step) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "props", thrift.MAP, 5); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:props: ", p), err) }
  if err := oprot.WriteMapBegin(ctx, thrift.STRING, thrift.STRUCT, len(p.Props)); err != nil {
    return thrift.PrependError("error writing map begin: ", err)
  }
  for k, v := range p.Props {
    if err := oprot.WriteString(ctx, string(k)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
    if err := v.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
    }
  }
  if err := oprot.WriteMapEnd(ctx); err != nil {
    return thrift.PrependError("error writing map end: ", err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 5:props: ", p), err) }
  return err
}

func (p *Step) Equals(other *Step) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if !p.Dst.Equals(other.Dst) { return false }
  if p.Type != other.Type { return false }
  if bytes.Compare(p.Name, other.Name) != 0 { return false }
  if p.Ranking != other.Ranking { return false }
  if len(p.Props) != len(other.Props) { return false }
  for k, _tgt := range p.Props {
    _src29 := other.Props[k]
    if !_tgt.Equals(_src29) { return false }
  }
  return true
}

func (p *Step) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("Step(%+v)", *p)
}

func (p *Step) Validate() error {
  return nil
}
// Attributes:
//  - Src
//  - Steps
type Path struct {
  Src *Vertex `thrift:"src,1" db:"src" json:"src"`
  Steps []*Step `thrift:"steps,2" db:"steps" json:"steps"`
}

func NewPath() *Path {
  return &Path{}
}

var Path_Src_DEFAULT *Vertex
func (p *Path) GetSrc() *Vertex {
  if !p.IsSetSrc() {
    return Path_Src_DEFAULT
  }
return p.Src
}

func (p *Path) GetSteps() []*Step {
  return p.Steps
}
func (p *Path) IsSetSrc() bool {
  return p.Src != nil
}

func (p *Path) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *Path)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Src = &Vertex{}
  if err := p.Src.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Src), err)
  }
  return nil
}

func (p *Path)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]*Step, 0, size)
  p.Steps =  tSlice
  for i := 0; i < size; i ++ {
    _elem30 := &Step{}
    if err := _elem30.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem30), err)
    }
    p.Steps = append(p.Steps, _elem30)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *Path) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "Path"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *Path) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "src", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:src: ", p), err) }
  if err := p.Src.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Src), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:src: ", p), err) }
  return err
}

func (p *Path) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "steps", thrift.LIST, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:steps: ", p), err) }
  if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.Steps)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
  }
  for _, v := range p.Steps {
    if err := v.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
    }
  }
  if err := oprot.WriteListEnd(ctx); err != nil {
    return thrift.PrependError("error writing list end: ", err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:steps: ", p), err) }
  return err
}

func (p *Path) Equals(other *Path) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if !p.Src.Equals(other.Src) { return false }
  if len(p.Steps) != len(other.Steps) { return false }
  for i, _tgt := range p.Steps {
    _src31 := other.Steps[i]
    if !_tgt.Equals(_src31) { return false }
  }
  return true
}

func (p *Path) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("Path(%+v)", *p)
}

func (p *Path) Validate() error {
  return nil
}
// Attributes:
//  - Host
//  - Port
type HostAddr struct {
  Host string `thrift:"host,1" db:"host" json:"host"`
  Port Port `thrift:"port,2" db:"port" json:"port"`
}

func NewHostAddr() *HostAddr {
  return &HostAddr{}
}


func (p *HostAddr) GetHost() string {
  return p.Host
}

func (p *HostAddr) GetPort() Port {
  return p.Port
}
func (p *HostAddr) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *HostAddr)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Host = v
}
  return nil
}

func (p *HostAddr)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  temp := Port(v)
  p.Port = temp
}
  return nil
}

func (p *HostAddr) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "HostAddr"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *HostAddr) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "host", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:host: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Host)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.host (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:host: ", p), err) }
  return err
}

func (p *HostAddr) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "port", thrift.I32, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:port: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.Port)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.port (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:port: ", p), err) }
  return err
}

func (p *HostAddr) Equals(other *HostAddr) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.Host != other.Host { return false }
  if p.Port != other.Port { return false }
  return true
}

func (p *HostAddr) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("HostAddr(%+v)", *p)
}

func (p *HostAddr) Validate() error {
  return nil
}
// Attributes:
//  - Key
//  - Value
type KeyValue struct {
  Key []byte `thrift:"key,1" db:"key" json:"key"`
  Value []byte `thrift:"value,2" db:"value" json:"value"`
}

func NewKeyValue() *KeyValue {
  return &KeyValue{}
}


func (p *KeyValue) GetKey() []byte {
  return p.Key
}

func (p *KeyValue) GetValue() []byte {
  return p.Value
}
func (p *KeyValue) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *KeyValue)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Key = v
}
  return nil
}

func (p *KeyValue)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.Value = v
}
  return nil
}

func (p *KeyValue) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "KeyValue"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *KeyValue) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "key", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:key: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Key); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.key (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:key: ", p), err) }
  return err
}

func (p *KeyValue) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "value", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:value: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Value); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.value (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:value: ", p), err) }
  return err
}

func (p *KeyValue) Equals(other *KeyValue) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if bytes.Compare(p.Key, other.Key) != 0 { return false }
  if bytes.Compare(p.Value, other.Value) != 0 { return false }
  return true
}

func (p *KeyValue) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("KeyValue(%+v)", *p)
}

func (p *KeyValue) Validate() error {
  return nil
}
// Attributes:
//  - Seconds
//  - Microseconds
//  - Months
type Duration struct {
  Seconds int64 `thrift:"seconds,1" db:"seconds" json:"seconds"`
  Microseconds int32 `thrift:"microseconds,2" db:"microseconds" json:"microseconds"`
  Months int32 `thrift:"months,3" db:"months" json:"months"`
}

func NewDuration() *Duration {
  return &Duration{}
}


func (p *Duration) GetSeconds() int64 {
  return p.Seconds
}

func (p *Duration) GetMicroseconds() int32 {
  return p.Microseconds
}

func (p *Duration) GetMonths() int32 {
  return p.Months
}
func (p *Duration) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *Duration)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Seconds = v
}
  return nil
}

func (p *Duration)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.Microseconds = v
}
  return nil
}

func (p *Duration)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.Months = v
}
  return nil
}

func (p *Duration) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "Duration"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *Duration) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "seconds", thrift.I64, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:seconds: ", p), err) }
  if err := oprot.WriteI64(ctx, int64(p.Seconds)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.seconds (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:seconds: ", p), err) }
  return err
}

func (p *Duration) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "microseconds", thrift.I32, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:microseconds: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.Microseconds)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.microseconds (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:microseconds: ", p), err) }
  return err
}

func (p *Duration) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "months", thrift.I32, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:months: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.Months)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.months (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:months: ", p), err) }
  return err
}

func (p *Duration) Equals(other *Duration) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.Seconds != other.Seconds { return false }
  if p.Microseconds != other.Microseconds { return false }
  if p.Months != other.Months { return false }
  return true
}

func (p *Duration) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("Duration(%+v)", *p)
}

func (p *Duration) Validate() error {
  return nil
}
// Attributes:
//  - LogID
//  - TermID
//  - CommitLogID
//  - CheckpointPath
type LogInfo struct {
  LogID LogID `thrift:"log_id,1" db:"log_id" json:"log_id"`
  TermID TermID `thrift:"term_id,2" db:"term_id" json:"term_id"`
  CommitLogID LogID `thrift:"commit_log_id,3" db:"commit_log_id" json:"commit_log_id"`
  CheckpointPath []byte `thrift:"checkpoint_path,4" db:"checkpoint_path" json:"checkpoint_path"`
}

func NewLogInfo() *LogInfo {
  return &LogInfo{}
}


func (p *LogInfo) GetLogID() LogID {
  return p.LogID
}

func (p *LogInfo) GetTermID() TermID {
  return p.TermID
}

func (p *LogInfo) GetCommitLogID() LogID {
  return p.CommitLogID
}

func (p *LogInfo) GetCheckpointPath() []byte {
  return p.CheckpointPath
}
func (p *LogInfo) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *LogInfo)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  temp := LogID(v)
  p.LogID = temp
}
  return nil
}

func (p *LogInfo)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  temp := TermID(v)
  p.TermID = temp
}
  return nil
}

func (p *LogInfo)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  temp := LogID(v)
  p.CommitLogID = temp
}
  return nil
}

func (p *LogInfo)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 4: ", err)
} else {
  p.CheckpointPath = v
}
  return nil
}

func (p *LogInfo) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "LogInfo"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *LogInfo) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "log_id", thrift.I64, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:log_id: ", p), err) }
  if err := oprot.WriteI64(ctx, int64(p.LogID)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.log_id (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:log_id: ", p), err) }
  return err
}

func (p *LogInfo) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "term_id", thrift.I64, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:term_id: ", p), err) }
  if err := oprot.WriteI64(ctx, int64(p.TermID)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.term_id (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:term_id: ", p), err) }
  return err
}

func (p *LogInfo) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "commit_log_id", thrift.I64, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:commit_log_id: ", p), err) }
  if err := oprot.WriteI64(ctx, int64(p.CommitLogID)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.commit_log_id (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:commit_log_id: ", p), err) }
  return err
}

func (p *LogInfo) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "checkpoint_path", thrift.STRING, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:checkpoint_path: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.CheckpointPath); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.checkpoint_path (4) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:checkpoint_path: ", p), err) }
  return err
}

func (p *LogInfo) Equals(other *LogInfo) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.LogID != other.LogID { return false }
  if p.TermID != other.TermID { return false }
  if p.CommitLogID != other.CommitLogID { return false }
  if bytes.Compare(p.CheckpointPath, other.CheckpointPath) != 0 { return false }
  return true
}

func (p *LogInfo) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("LogInfo(%+v)", *p)
}

func (p *LogInfo) Validate() error {
  return nil
}
// Attributes:
//  - Root
//  - Data
type DirInfo struct {
  Root []byte `thrift:"root,1" db:"root" json:"root"`
  Data [][]byte `thrift:"data,2" db:"data" json:"data"`
}

func NewDirInfo() *DirInfo {
  return &DirInfo{}
}


func (p *DirInfo) GetRoot() []byte {
  return p.Root
}

func (p *DirInfo) GetData() [][]byte {
  return p.Data
}
func (p *DirInfo) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *DirInfo)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Root = v
}
  return nil
}

func (p *DirInfo)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([][]byte, 0, size)
  p.Data =  tSlice
  for i := 0; i < size; i ++ {
var _elem32 []byte
    if v, err := iprot.ReadBinary(ctx); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    _elem32 = v
}
    p.Data = append(p.Data, _elem32)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *DirInfo) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "DirInfo"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *DirInfo) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "root", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:root: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.Root); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.root (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:root: ", p), err) }
  return err
}

func (p *DirInfo) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "data", thrift.LIST, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:data: ", p), err) }
  if err := oprot.WriteListBegin(ctx, thrift.STRING, len(p.Data)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
  }
  for _, v := range p.Data {
    if err := oprot.WriteBinary(ctx, v); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
  }
  if err := oprot.WriteListEnd(ctx); err != nil {
    return thrift.PrependError("error writing list end: ", err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:data: ", p), err) }
  return err
}

func (p *DirInfo) Equals(other *DirInfo) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if bytes.Compare(p.Root, other.Root) != 0 { return false }
  if len(p.Data) != len(other.Data) { return false }
  for i, _tgt := range p.Data {
    _src33 := other.Data[i]
    if bytes.Compare(_tgt, _src33) != 0 { return false }
  }
  return true
}

func (p *DirInfo) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("DirInfo(%+v)", *p)
}

func (p *DirInfo) Validate() error {
  return nil
}
// Attributes:
//  - SpaceID
//  - Parts
//  - DataPath
type CheckpointInfo struct {
  SpaceID GraphSpaceID `thrift:"space_id,1" db:"space_id" json:"space_id"`
  Parts map[PartitionID]*LogInfo `thrift:"parts,2" db:"parts" json:"parts"`
  DataPath []byte `thrift:"data_path,3" db:"data_path" json:"data_path"`
}

func NewCheckpointInfo() *CheckpointInfo {
  return &CheckpointInfo{}
}


func (p *CheckpointInfo) GetSpaceID() GraphSpaceID {
  return p.SpaceID
}

func (p *CheckpointInfo) GetParts() map[PartitionID]*LogInfo {
  return p.Parts
}

func (p *CheckpointInfo) GetDataPath() []byte {
  return p.DataPath
}
func (p *CheckpointInfo) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.MAP {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *CheckpointInfo)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  temp := GraphSpaceID(v)
  p.SpaceID = temp
}
  return nil
}

func (p *CheckpointInfo)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  _, _, size, err := iprot.ReadMapBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading map begin: ", err)
  }
  tMap := make(map[PartitionID]*LogInfo, size)
  p.Parts =  tMap
  for i := 0; i < size; i ++ {
var _key34 PartitionID
    if v, err := iprot.ReadI32(ctx); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    temp := PartitionID(v)
    _key34 = temp
}
    _val35 := &LogInfo{}
    if err := _val35.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _val35), err)
    }
    p.Parts[_key34] = _val35
  }
  if err := iprot.ReadMapEnd(ctx); err != nil {
    return thrift.PrependError("error reading map end: ", err)
  }
  return nil
}

func (p *CheckpointInfo)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.DataPath = v
}
  return nil
}

func (p *CheckpointInfo) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "CheckpointInfo"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *CheckpointInfo) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "space_id", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:space_id: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.SpaceID)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.space_id (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:space_id: ", p), err) }
  return err
}

func (p *CheckpointInfo) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "parts", thrift.MAP, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:parts: ", p), err) }
  if err := oprot.WriteMapBegin(ctx, thrift.I32, thrift.STRUCT, len(p.Parts)); err != nil {
    return thrift.PrependError("error writing map begin: ", err)
  }
  for k, v := range p.Parts {
    if err := oprot.WriteI32(ctx, int32(k)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
    if err := v.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
    }
  }
  if err := oprot.WriteMapEnd(ctx); err != nil {
    return thrift.PrependError("error writing map end: ", err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:parts: ", p), err) }
  return err
}

func (p *CheckpointInfo) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "data_path", thrift.STRING, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:data_path: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.DataPath); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.data_path (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:data_path: ", p), err) }
  return err
}

func (p *CheckpointInfo) Equals(other *CheckpointInfo) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.SpaceID != other.SpaceID { return false }
  if len(p.Parts) != len(other.Parts) { return false }
  for k, _tgt := range p.Parts {
    _src36 := other.Parts[k]
    if !_tgt.Equals(_src36) { return false }
  }
  if bytes.Compare(p.DataPath, other.DataPath) != 0 { return false }
  return true
}

func (p *CheckpointInfo) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("CheckpointInfo(%+v)", *p)
}

func (p *CheckpointInfo) Validate() error {
  return nil
}
// Attributes:
//  - Cluster
//  - LogStr
type LogEntry struct {
  Cluster ClusterID `thrift:"cluster,1" db:"cluster" json:"cluster"`
  LogStr []byte `thrift:"log_str,2" db:"log_str" json:"log_str"`
}

func NewLogEntry() *LogEntry {
  return &LogEntry{}
}


func (p *LogEntry) GetCluster() ClusterID {
  return p.Cluster
}

func (p *LogEntry) GetLogStr() []byte {
  return p.LogStr
}
func (p *LogEntry) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *LogEntry)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  temp := ClusterID(v)
  p.Cluster = temp
}
  return nil
}

func (p *LogEntry)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.LogStr = v
}
  return nil
}

func (p *LogEntry) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "LogEntry"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *LogEntry) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "cluster", thrift.I64, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:cluster: ", p), err) }
  if err := oprot.WriteI64(ctx, int64(p.Cluster)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.cluster (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:cluster: ", p), err) }
  return err
}

func (p *LogEntry) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "log_str", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:log_str: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.LogStr); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.log_str (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:log_str: ", p), err) }
  return err
}

func (p *LogEntry) Equals(other *LogEntry) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.Cluster != other.Cluster { return false }
  if bytes.Compare(p.LogStr, other.LogStr) != 0 { return false }
  return true
}

func (p *LogEntry) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("LogEntry(%+v)", *p)
}

func (p *LogEntry) Validate() error {
  return nil
}
